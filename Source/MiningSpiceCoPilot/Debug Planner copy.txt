  "thought": "Now I'll implement the ServiceManager.h header file:\n\n```cpp\n// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"DependencyResolver.h\"\n#include \"Interfaces/IServiceLocator.h\"\n#include \"Interfaces/IMemoryManager.h\"\n#include \"HAL/ThreadSafeBool.h\"\n#include \"HAL/CriticalSection.h\"\n#include \"Containers/Map.h\"\n#include \"Templates/SharedPointer.h\"\n#include \"Misc/Optional.h\"\n#include \"Containers/Queue.h\"\n#include \"HAL/ThreadSafeCounter.h\"\n\n/**\n * Service state enumeration\n */\nenum class EServiceState : uint8\n{\n    /** Service is not initialized */\n    Uninitialized,\n    \n    /** Service is initializing */\n    Initializing,\n    \n    /** Service is active and functioning normally */\n    Active,\n    \n    /** Service is experiencing failures */\n    Failing,\n    \n    /** Service is shutting down */\n    ShuttingDown,\n    \n    /** Service is destroyed */\n    Destroyed\n};\n\n/**\n * Structure for tracking service metrics\n */\nstruct FServiceMetrics\n{\n    /** Number of successful operations */\n    FThreadSafeCounter64 SuccessfulOperations;\n    \n    /** Number of failed operations */\n    FThreadSafeCounter64 FailedOperations;\n    \n    /** Total operation time in milliseconds */\n    FThreadSafeCounter64 TotalOperationTimeMs;\n    \n    /** Maximum operation time in milliseconds */\n    FThreadSafeCounter64 MaxOperationTimeMs;\n    \n    /** Memory used by the service in bytes */\n    FThreadSafeCounter64 MemoryUsageBytes;\n    \n    /** Number of active instances */\n    FThreadSafeCounter ActiveInstances;\n    \n    /** Time of last health check */\n    double LastHealthCheckTime;\n    \n    /** Time of last failure */\n    double LastFailureTime;\n    \n    /** Time of last recovery */\n    double LastRecoveryTime;\n    \n    /** Default constructor */\n    FServiceMetrics()\n        : LastHealthCheckTime(0.0)\n        , LastFailureTime(0.0)\n        , LastRecoveryTime(0.0)\n    {\n    }\n    \n    /** Resets all metrics */\n    void Reset()\n    {\n        SuccessfulOperations.Set(0);\n        FailedOperations.Set(0);\n        TotalOperationTimeMs.Set(0);\n        MaxOperationTimeMs.Set(0);\n        MemoryUsageBytes.Set(0);\n        ActiveInstances.Set(0);\n        LastHealthCheckTime = 0.0;\n        LastFailureTime = 0.0;\n        LastRecoveryTime = 0.0;\n    }\n};\n\n/**\n * Structure for service instance\n */\nstruct FServiceInstance\n{\n    /** Service interface class */\n    const UClass* InterfaceType;\n    \n    /** Service implementation pointer */\n    void* ServicePtr;\n    \n    /** Current state of the service */\n    EServiceState State;\n    \n    /** Zone ID for zone-specific services */\n    int32 ZoneID;\n    \n    /** Region ID for region-specific services */\n    int32 RegionID;\n    \n    /** Metrics for this service */\n    FServiceMetrics Metrics;\n    \n    /** Saved state for recovery */\n    TArray<uint8> SavedState;\n    \n    /** Whether this service is part of a pool */\n    bool bIsPooled;\n    \n    /** Time when the service was created */\n    double CreationTime;\n    \n    /** Time when the service was last accessed */\n    double LastAccessTime;\n    \n    /** Default constructor */\n    FServiceInstance()\n        : InterfaceType(nullptr)\n        , ServicePtr(nullptr)\n        , State(EServiceState::Uninitialized)\n        , ZoneID(INDEX_NONE)\n        , RegionID(INDEX_NONE)\n        , bIsPooled(false)\n        , CreationTime(0.0)\n        , LastAccessTime(0.0)\n    {\n    }\n};\n\n/**\n * Service configuration structure\n */\nstruct FServiceConfiguration\n{\n    /** Map of configuration parameters */\n    TMap<FName, FString> Parameters;\n    \n    /** Whether this service can be recovered after failure */\n    bool bCanRecover;\n    \n    /** Whether this service should save state for recovery */\n    bool bSaveStateForRecovery;\n    \n    /** Whether this service should be pooled */\n    bool bEnablePooling;\n    \n    /** Maximum size of service pool */\n    int32 MaxPoolSize;\n    \n    /** Default constructor */\n    FServiceConfiguration()\n        : bCanRecover(true)\n        , bSaveStateForRecovery(true)\n        , bEnablePooling(false)\n        , MaxPoolSize(5)\n    {\n    }\n};\n\n/**\n * Service manager for the mining system\n * Manages service lifecycle, initialization ordering, and performance metrics\n */\nclass MININGSPICECOPILOT_API FServiceManager\n{\npublic:\n    /** Default constructor */\n    FServiceManager();\n    \n    /** Destructor */\n    ~FServiceManager();\n    \n    /**\n     * Initialize the service manager\n     * @return True if initialization was successful\n     */\n    bool Initialize();\n    \n    /**\n     * Shutdown the service manager\n     */\n    void Shutdown();\n    \n    /**\n     * Check if the service manager is initialized\n     * @return True if initialized\n     */\n    bool IsInitialized() const;\n    \n    /**\n     * Register a service with the manager\n     * @param InService Pointer to the service implementation\n     * @param InInterfaceType Type information for the service interface\n     * @param InConfiguration Optional configuration for the service\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @return True if registration was successful\n     */\n    bool RegisterService(void* InService, const UClass* InInterfaceType, \n        const FServiceConfiguration& InConfiguration = FServiceConfiguration(),\n        int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE);\n    \n    /**\n     * Template method to register a typed service\n     * @param InService Pointer to the service implementation\n     * @param InConfiguration Optional configuration for the service\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @return True if registration was successful\n     */\n    template<typename T>\n    bool RegisterService(T* InService, \n        const FServiceConfiguration& InConfiguration = FServiceConfiguration(),\n        int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE)\n    {\n        return RegisterService(static_cast<void*>(InService), T::StaticClass(), \n            InConfiguration, InZoneID, InRegionID);\n    }\n    \n    /**\n     * Unregister a service from the manager\n     * @param InInterfaceType Type information for the service interface\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @return True if unregistration was successful\n     */\n    bool UnregisterService(const UClass* InInterfaceType, \n        int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE);\n    \n    /**\n     * Template method to unregister a typed service\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @return True if unregistration was successful\n     */\n    template<typename T>\n    bool UnregisterService(int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE)\n    {\n        return UnregisterService(T::StaticClass(), InZoneID, InRegionID);\n    }\n    \n    /**\n     * Start a service\n     * @param InInterfaceType Type information for the service interface\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @return True if service was started successfully\n     */\n    bool StartService(const UClass* InInterfaceType, \n        int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE);\n    \n    /**\n     * Template method to start a typed service\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @return True if service was started successfully\n     */\n    template<typename T>\n    bool StartService(int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE)\n    {\n        return StartService(T::StaticClass(), InZoneID, InRegionID);\n    }\n    \n    /**\n     * Stop a service\n     * @param InInterfaceType Type information for the service interface\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @return True if service was stopped successfully\n     */\n    bool StopService(const UClass* InInterfaceType, \n        int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE);\n    \n    /**\n     * Template method to stop a typed service\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @return True if service was stopped successfully\n     */\n    template<typename T>\n    bool StopService(int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE)\n    {\n        return StopService(T::StaticClass(), InZoneID, InRegionID);\n    }\n    \n    /**\n     * Restart a service\n     * @param InInterfaceType Type information for the service interface\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @param bPreserveState Whether to preserve state during restart\n     * @return True if service was restarted successfully\n     */\n    bool RestartService(const UClass* InInterfaceType, \n        int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE,\n        bool bPreserveState = true);\n    \n    /**\n     * Template method to restart a typed service\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @param bPreserveState Whether to preserve state during restart\n     * @return True if service was restarted successfully\n     */\n    template<typename T>\n    bool RestartService(int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE,\n        bool bPreserveState = true)\n    {\n        return RestartService(T::StaticClass(), InZoneID, InRegionID, bPreserveState);\n    }\n    \n    /**\n     * Get the state of a service\n     * @param InInterfaceType Type information for the service interface\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @return State of the service or Uninitialized if not found\n     */\n    EServiceState GetServiceState(const UClass* InInterfaceType, \n        int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE) const;\n    \n    /**\n     * Template method to get the state of a typed service\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @return State of the service or Uninitialized if not found\n     */\n    template<typename T>\n    EServiceState GetServiceState(int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE) const\n    {\n        return GetServiceState(T::StaticClass(), InZoneID, InRegionID);\n    }\n    \n    /**\n     * Get the metrics for a service\n     * @param InInterfaceType Type information for the service interface\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @return Metrics for the service or nullptr if not found\n     */\n    const FServiceMetrics* GetServiceMetrics(const UClass* InInterfaceType, \n        int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE) const;\n    \n    /**\n     * Template method to get the metrics for a typed service\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @return Metrics for the service or nullptr if not found\n     */\n    template<typename T>\n    const FServiceMetrics* GetServiceMetrics(int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE) const\n    {\n        return GetServiceMetrics(T::StaticClass(), InZoneID, InRegionID);\n    }\n    \n    /**\n     * Record operation metrics for a service\n     * @param InInterfaceType Type information for the service interface\n     * @param bSuccess Whether the operation was successful\n     * @param DurationMs Duration of the operation in milliseconds\n     * @param MemoryUsed Memory used by the operation in bytes\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     */\n    void RecordServiceMetrics(const UClass* InInterfaceType, \n        bool bSuccess, float DurationMs, uint64 MemoryUsed = 0,\n        int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE);\n    \n    /**\n     * Template method to record operation metrics for a typed service\n     * @param bSuccess Whether the operation was successful\n     * @param DurationMs Duration of the operation in milliseconds\n     * @param MemoryUsed Memory used by the operation in bytes\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     */\n    template<typename T>\n    void RecordServiceMetrics(bool bSuccess, float DurationMs, uint64 MemoryUsed = 0,\n        int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE)\n    {\n        RecordServiceMetrics(T::StaticClass(), bSuccess, DurationMs, MemoryUsed, InZoneID, InRegionID);\n    }\n    \n    /**\n     * Get a service from the pool or create a new instance\n     * @param InInterfaceType Type information for the service interface\n     * @param InZoneID Zone identifier for the service\n     * @return Pointer to the service or nullptr if unable to acquire\n     */\n    void* AcquirePooledService(const UClass* InInterfaceType, int32 InZoneID);\n    \n    /**\n     * Template method to get a typed service from the pool\n     * @param InZoneID Zone identifier for the service\n     * @return Pointer to the typed service or nullptr if unable to acquire\n     */\n    template<typename T>\n    T* AcquirePooledService(int32 InZoneID)\n    {\n        return static_cast<T*>(AcquirePooledService(T::StaticClass(), InZoneID));\n    }\n    \n    /**\n     * Return a service to the pool\n     * @param InService Pointer to the service\n     * @param InInterfaceType Type information for the service interface\n     * @param InZoneID Zone identifier for the service\n     * @return True if the service was returned to the pool successfully\n     */\n    bool ReleasePooledService(void* InService, const UClass* InInterfaceType, int32 InZoneID);\n    \n    /**\n     * Template method to return a typed service to the pool\n     * @param InService Pointer to the typed service\n     * @param InZoneID Zone identifier for the service\n     * @return True if the service was returned to the pool successfully\n     */\n    template<typename T>\n    bool ReleasePooledService(T* InService, int32 InZoneID)\n    {\n        return ReleasePooledService(static_cast<void*>(InService), T::StaticClass(), InZoneID);\n    }\n    \n    /**\n     * Create a service pool for a specific type and zone\n     * @param InInterfaceType Type information for the service interface\n     * @param InZoneID Zone identifier for the services\n     * @param InMaxPoolSize Maximum size of the pool\n     * @return True if the pool was created successfully\n     */\n    bool CreateServicePool(const UClass* InInterfaceType, int32 InZoneID, int32 InMaxPoolSize = 5);\n    \n    /**\n     * Template method to create a service pool for a specific type and zone\n     * @param InZoneID Zone identifier for the services\n     * @param InMaxPoolSize Maximum size of the pool\n     * @return True if the pool was created successfully\n     */\n    template<typename T>\n    bool CreateServicePool(int32 InZoneID, int32 InMaxPoolSize = 5)\n    {\n        return CreateServicePool(T::StaticClass(), InZoneID, InMaxPoolSize);\n    }\n    \n    /**\n     * Reconfigure a service with new parameters\n     * @param InInterfaceType Type information for the service interface\n     * @param InConfiguration New configuration for the service\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @return True if reconfiguration was successful\n     */\n    bool ReconfigureService(const UClass* InInterfaceType, \n        const FServiceConfiguration& InConfiguration,\n        int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE);\n    \n    /**\n     * Template method to reconfigure a typed service\n     * @param InConfiguration New configuration for the service\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @return True if reconfiguration was successful\n     */\n    template<typename T>\n    bool ReconfigureService(const FServiceConfiguration& InConfiguration,\n        int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE)\n    {\n        return ReconfigureService(T::StaticClass(), InConfiguration, InZoneID, InRegionID);\n    }\n    \n    /**\n     * Get the configuration of a service\n     * @param InInterfaceType Type information for the service interface\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @return Configuration of the service or default if not found\n     */\n    FServiceConfiguration GetServiceConfiguration(const UClass* InInterfaceType,\n        int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE) const;\n    \n    /**\n     * Template method to get the configuration of a typed service\n     * @param InZoneID Optional zone identifier for zone-specific services\n     * @param InRegionID Optional region identifier for region-specific services\n     * @return Configuration of the service or default if not found\n     */\n    template<typename T>\n    FServiceConfiguration GetServiceConfiguration(int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE) const\n    {\n        return GetServiceConfiguration(T::StaticClass(), InZoneID, InRegionID);\n    }\n    \n    /**\n     * Get all services managed by the manager\n     * @return Array of service instances\n     */\n    TArray<FServiceInstance> GetAllServices() const;\n    \n    /**\n     * Get services by state\n     * @param InState State to filter by\n     * @return Array of service instances in the specified state\n     */\n    TArray<FServiceInstance> GetServicesByState(EServiceState InState) const;\n    \n    /**\n     * Get the singleton instance of the service manager\n     * @return Reference to the service manager instance\n     */\n    static FServiceManager& Get();\n\nprivate:\n    /**\n     * Create a unique key for a service\n     * @param InInterfaceType Type information for the service interface\n     * @param InZoneID Zone identifier for the service\n     * @param InRegionID Region identifier for the service\n     * @return Unique key for the service\n     */\n    FName CreateServiceKey(const UClass* InInterfaceType, int32 InZoneID, int32 InRegionID) const;\n    \n    /**\n     * Get a service instance by key\n     * @param InKey Service key\n     * @return Pointer to the service instance or nullptr if not found\n     */\n    FServiceInstance* GetServiceInstanceByKey(const FName& InKey);\n    \n    /**\n     * Get a const service instance by key\n     * @param InKey Service key\n     * @return Const pointer to the service instance or nullptr if not found\n     */\n    const FServiceInstance* GetServiceInstanceByKey(const FName& InKey) const;\n    \n    /**\n     * Determine service initialization order based on dependencies\n     * @param OutInitializationOrder Array to receive the initialization order\n     * @param OutErrors Array to receive error messages\n     * @return True if initialization order was determined successfully\n     */\n    bool DetermineServiceOrder(TArray<FName>& OutInitializationOrder, TArray<FString>& OutErrors);\n    \n    /**\n     * Start services in the specified order\n     * @param InOrder Array of service keys in initialization order\n     * @return True if all services were started successfully\n     */\n    bool StartServicesInOrder(const TArray<FName>& InOrder);\n    \n    /**\n     * Stop services in the reverse specified order\n     * @param InOrder Array of service keys in initialization order\n     * @return True if all services were stopped successfully\n     */\n    bool StopServicesInOrder(const TArray<FName>& InOrder);\n    \n    /**\n     * Save service state for recovery\n     * @param InInstance Service instance to save state for\n     * @return True if state was saved successfully\n     */\n    bool SaveServiceState(FServiceInstance& InInstance);\n    \n    /**\n     * Restore service state after recovery\n     * @param InInstance Service instance to restore state for\n     * @return True if state was restored successfully\n     */\n    bool RestoreServiceState(FServiceInstance& InInstance);\n    \n    /**\n     * Clean up service pools\n     */\n    void CleanupServicePools();\n    \n    /**\n     * Update service metrics for all services\n     */\n    void UpdateAllServiceMetrics();\n    \n    /**\n     * Create a service factory and register dependencies\n     * @param InInterfaceType Type information for the service interface\n     * @return True if factory was created successfully\n     */\n    bool CreateServiceFactoryAndDependencies(const UClass* InInterfaceType);\n\n    /** Map of service instances by key */\n    TMap<FName, FServiceInstance> ServiceInstances;\n    \n    /** Map of service configurations by key */\n    TMap<FName, FServiceConfiguration> ServiceConfigurations;\n    \n    /** Map of service pools by type and zone */\n    TMap<FName, TQueue<void*>> ServicePools;\n    \n    /** Map of service pool sizes by type and zone */\n    TMap<FName, int32> ServicePoolSizes;\n    \n    /** Dependency resolver for determining initialization order */\n    TSharedPtr<FDependencyResolver> DependencyResolver;\n    \n    /** Service locator reference */\n    IServiceLocator* ServiceLocator;\n    \n    /** Memory manager reference */\n    IMemoryManager* MemoryManager;\n    \n    /** Lock for thread-safe access to service instances */\n    mutable FCriticalSection InstancesLock;\n    \n    /** Lock for thread-safe access to service pools */\n    mutable FCriticalSection PoolsLock;\n    \n    /** Flag indicating if the manager is initialized */\n    FThreadSafeBool bIsInitialized;\n    \n    /** Singleton instance */\n    static FServiceManager* ManagerInstance;\n    \n    /** Critical section for singleton initialization */\n    static FCriticalSection SingletonLock;\n};\n```\n\nThis header provides a comprehensive interface for the ServiceManager, including service lifecycle management, pooling, metrics collection, and configuration.",
