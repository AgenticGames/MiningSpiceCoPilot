## SYSTEM 2: Memory Management System

### Class Hierarchy
- `IMemoryManager` [2_MemoryManagement/Public/Interfaces/IMemoryManager.h]: Interface
  - Purpose: Provides comprehensive memory management capabilities optimized for mining operations
  - Key methods:
    - `bool Initialize()` - Initializes the memory manager
    - `void Shutdown()` - Shuts down the memory manager and cleans up resources
    - `bool IsInitialized() const` - Checks initialization status
    - `IPoolAllocator* CreatePool(const FName& PoolName, uint32 BlockSize, uint32 BlockCount, EMemoryAccessPattern AccessPattern, bool bAllowGrowth)` - Creates a memory pool with specified characteristics
    - `IPoolAllocator* GetPool(const FName& PoolName) const` - Gets a pool allocator by name
    - `IBufferProvider* CreateBuffer(const FName& BufferName, uint64 SizeInBytes, bool bZeroCopy, bool bGPUWritable)` - Creates a shared buffer for CPU/GPU operations
    - `IBufferProvider* GetBuffer(const FName& BufferName) const` - Gets a buffer provider by name
    - `IMemoryTracker* GetMemoryTracker() const` - Gets the memory tracker for telemetry
    - `bool DefragmentMemory(float MaxTimeMs, EMemoryPriority Priority)` - Performs memory defragmentation
    - `void* Allocate(uint64 SizeInBytes, uint32 Alignment = 16)` - Allocates memory from the general heap
    - `void Free(void* Ptr)` - Frees memory previously allocated with Allocate
    - `void SetMemoryBudget(const FName& CategoryName, uint64 BudgetInBytes)` - Sets memory budget for a category
    - `uint64 GetMemoryBudget(const FName& CategoryName) const` - Gets memory budget for a category
    - `uint64 GetMemoryUsage(const FName& CategoryName) const` - Gets memory usage for a category
    - `void RegisterAllocation(void* Ptr, uint64 SizeInBytes, const FName& CategoryName, const FName& AllocationName)` - Registers a memory allocation for tracking
    - `void UnregisterAllocation(void* Ptr, const FName& CategoryName)` - Unregisters a memory allocation
    - `bool SetNUMAPolicy(bool bUseNUMAAwareness, int32 PreferredNode)` - Sets NUMA policy for memory allocations
    - `bool IsSupported() const` - Checks if the memory manager is supported on the current platform
    - `static IMemoryManager& Get()` - Gets the singleton instance

- `FMemoryPoolManager` [2_MemoryManagement/Public/MemoryPoolManager.h]: Implements IMemoryManager
  - Purpose: Concrete implementation of the memory manager with specialized allocators for mining operations
  - Key methods:
    - Implementation of IMemoryManager interface
    - `IPoolAllocator* CreateSVONodePool(const FName& PoolName, uint32 NodeSize, uint32 NodeCount)` - Creates a specialized pool for SVO nodes
    - Static memory budget constants:
      - `DEFAULT_BUDGET_SVO_NODES = 256 * 1024 * 1024` - 256 MB for SVO nodes
      - `DEFAULT_BUDGET_SDF_FIELDS = 512 * 1024 * 1024` - 512 MB for SDF fields
      - `DEFAULT_BUDGET_NARROW_BAND = 128 * 1024 * 1024` - 128 MB for narrow band
      - `DEFAULT_BUDGET_MATERIAL_CHANNELS = 256 * 1024 * 1024` - 256 MB for material channels
      - `DEFAULT_BUDGET_MESH_DATA = 128 * 1024 * 1024` - 128 MB for mesh data
      - `DEFAULT_BUDGET_GENERAL = 64 * 1024 * 1024` - 64 MB for general purpose
    - Memory pressure thresholds:
      - `MEMORY_PRESSURE_THRESHOLD = 0.15f` - 15% free memory triggers pressure warning
      - `MEMORY_CRITICAL_THRESHOLD = 0.05f` - 5% free memory triggers critical pressure
  - Key members:
    - `IMemoryTracker* MemoryTracker` - Memory tracking component
    - `IMemoryDefragmenter* Defragmenter` - Memory defragmentation component
    - `TMap<FName, TSharedPtr<IPoolAllocator>> Pools` - Map of memory pools
    - `TMap<FName, TSharedPtr<IBufferProvider>> Buffers` - Map of buffer providers
    - `FRWLock PoolsLock` - Read-write lock for thread-safe pool access
    - `FRWLock BuffersLock` - Read-write lock for thread-safe buffer access
    - `bool bIsInitialized` - Initialization flag
    - `bool bNUMAAwarenessEnabled` - Whether NUMA policy is enabled
    - `int32 NUMAPreferredNode` - Preferred NUMA node when enabled
    - `FCriticalSection SingletonLock` - Lock for singleton access
    - `static FMemoryPoolManager* ManagerInstance` - Singleton instance

- `IMemoryTracker` [2_MemoryManagement/Public/Interfaces/IMemoryTracker.h]: Interface
  - Purpose: Provides memory telemetry and monitoring functionality
  - Key methods:
    - `bool Initialize()` - Initializes the memory tracker
    - `void Shutdown()` - Shuts down the memory tracker and cleans up resources
    - `bool IsInitialized() const` - Checks initialization status
    - `bool TrackAllocation(void* Ptr, uint64 SizeInBytes, const FName& CategoryName, const FName& AllocationName)` - Tracks a memory allocation
    - `bool UntrackAllocation(void* Ptr)` - Untracks a memory allocation
    - `const FMemoryAllocationInfo* GetAllocationInfo(void* Ptr) const` - Gets allocation info
    - `FMemoryStats GetMemoryStats() const` - Gets current memory statistics
    - `FSVOSDFMemoryMetrics GetSVOSDFMemoryMetrics() const` - Gets SVO+SDF specific memory metrics
    - `void SetMemoryBudget(const FName& CategoryName, uint64 BudgetInBytes)` - Sets memory budget
    - `uint64 GetMemoryBudget(const FName& CategoryName) const` - Gets memory budget
    - `uint64 GetMemoryUsage(const FName& CategoryName) const` - Gets memory usage

- `FMemoryTelemetry` [2_MemoryManagement/Public/MemoryTelemetry.h]: Implements IMemoryTracker
  - Purpose: Concrete implementation of memory tracking and telemetry
  - Key methods:
    - Implementation of IMemoryTracker interface
    - Memory usage visualization and reporting functions
    - Memory leak detection and tracking
  - Key members:
    - `TMap<void*, FMemoryAllocationInfo> AllocationsMap` - Map of tracked allocations
    - `TMap<FName, uint64> CategoryBudgets` - Budget for each memory category
    - `TMap<FName, uint64> CategoryUsage` - Current usage for each category
    - `FCriticalSection AllocationLock` - Thread safety for allocation tracking

- `IMemoryDefragmenter` [2_MemoryManagement/Public/Interfaces/IMemoryDefragmenter.h]: Interface
  - Purpose: Provides memory defragmentation functionality to optimize memory layout
  - Key methods:
    - `bool Initialize()` - Initializes the defragmenter
    - `void Shutdown()` - Shuts down the defragmenter
    - `bool IsInitialized() const` - Checks initialization status
    - `bool DefragmentMemory(float MaxTimeMs, EMemoryPriority Priority)` - Performs defragmentation within time budget
    - `bool RegisterPool(IPoolAllocator* Pool)` - Registers a pool for defragmentation
    - `bool UnregisterPool(const FName& PoolName)` - Unregisters a pool
    - `float GetFragmentationPercent() const` - Gets current fragmentation percentage

- `FMemoryDefragmenter` [2_MemoryManagement/Public/MemoryDefragmenter.h]: Implements IMemoryDefragmenter
  - Purpose: Concrete implementation of memory defragmentation
  - Key methods:
    - Implementation of IMemoryDefragmenter interface
    - Time-sliced defragmentation algorithms
    - Priority-based defragmentation scheduling
  - Key members:
    - `TMap<FName, IPoolAllocator*> RegisteredPools` - Map of pools registered for defragmentation
    - `bool bIsDefragmenting` - Whether defragmentation is in progress
    - `FCriticalSection DefragmentationLock` - Thread safety for defragmentation operations

- `IPoolAllocator` [2_MemoryManagement/Public/Interfaces/IPoolAllocator.h]: Interface
  - Purpose: Provides block-based memory allocation optimized for specific use cases
  - Key methods:
    - `bool Initialize()` - Initializes the pool allocator
    - `void Shutdown()` - Shuts down the pool allocator
    - `bool IsInitialized() const` - Checks initialization status
    - `FName GetPoolName() const` - Gets the name of this pool
    - `uint32 GetBlockSize() const` - Gets the block size for this pool
    - `void* Allocate(const UObject* RequestingObject = nullptr, FName AllocationTag = NAME_None)` - Allocates a block
    - `bool Free(void* Ptr)` - Frees a previously allocated block
    - `bool Grow(uint32 AdditionalBlockCount, bool bForceGrowth = false)` - Attempts to grow the pool
    - `uint32 Shrink(uint32 MaxBlocksToRemove = UINT32_MAX)` - Attempts to shrink the pool
    - `bool OwnsPointer(const void* Ptr) const` - Checks if a pointer belongs to this pool
    - `FPoolStats GetStats() const` - Gets current pool statistics
    - `bool Defragment(float MaxTimeMs = 5.0f)` - Performs defragmentation on the pool

- `FSVOAllocator` [2_MemoryManagement/Public/SVOAllocator.h]: Implements IPoolAllocator
  - Purpose: Specialized allocator for SVO (Sparse Voxel Octree) nodes
  - Key methods:
    - Implementation of IPoolAllocator interface
    - Octree-specific allocation optimizations
    - Spatial locality improvements for traversal
  - Key members:
    - `TArray<uint8*> MemoryBlocks` - Array of memory block pointers
    - `TArray<uint32> FreeIndices` - Free block indices for fast allocation
    - `TBitArray<> AllocationMap` - Bitmap of allocated blocks

- `INarrowBandAllocator` [2_MemoryManagement/Public/Interfaces/INarrowBandAllocator.h]: Interface
  - Purpose: Specialized allocator for narrow band SDF data with high precision
  - Key methods:
    - IPoolAllocator interface implementation
    - Narrow band specific allocation methods

- `FNarrowBandAllocator` [2_MemoryManagement/Public/NarrowBandAllocator.h]: Implements INarrowBandAllocator
  - Purpose: Concrete implementation of narrow band allocator for high-precision SDF
  - Key methods:
    - Implementation of INarrowBandAllocator interface
    - Narrow band optimization algorithms
  - Key members:
    - Narrow band width and precision configuration
    - Spatial hashing for efficient lookup

- `IBufferProvider` [2_MemoryManagement/Public/Interfaces/IBufferProvider.h]: Interface
  - Purpose: Provides buffer sharing between CPU and GPU components with efficient synchronization
  - Key methods:
    - `bool Initialize()` - Initializes the buffer provider
    - `void Shutdown()` - Shuts down the buffer provider 
    - `bool IsInitialized() const` - Checks initialization status
    - `FName GetBufferName() const` - Gets the name of this buffer
    - `uint64 GetSizeInBytes() const` - Gets the size of this buffer
    - `void* Map(EBufferAccessMode AccessMode = EBufferAccessMode::ReadWrite)` - Maps buffer for CPU access
    - `bool Unmap()` - Unmaps the buffer, making changes visible to GPU
    - `bool IsMapped() const` - Checks if the buffer is currently mapped
    - `bool Resize(uint64 NewSizeInBytes, bool bPreserveContent = true)` - Resizes the buffer
    - `void* GetGPUResource() const` - Gets underlying GPU resource
    - `void AddRef()` - Adds a reference to this buffer
    - `uint32 Release()` - Releases a reference to this buffer
    - `FBufferStats GetStats() const` - Gets current buffer statistics
    - `void SetUsageHint(EBufferUsage UsageHint)` - Sets usage hint for optimization
    - `EBufferUsage GetUsageHint() const` - Gets current usage hint
    - `bool SupportsZeroCopy() const` - Checks if zero-copy is supported
    - `bool IsGPUWritable() const` - Checks if GPU can write to buffer
    - `uint64 GetVersionNumber() const` - Gets buffer version number

- `FZeroCopyBuffer` [2_MemoryManagement/Public/ZeroCopyBuffer.h]: Implements IBufferProvider
  - Purpose: Zero-copy buffer implementation for GPU/CPU data sharing with minimal synchronization overhead
  - Key methods:
    - Implementation of IBufferProvider interface
    - `FStructuredBufferRHIRef GetRHIBuffer() const` - Gets the RHI structured buffer resource
    - `FShaderResourceViewRHIRef GetShaderResourceView() const` - Gets SRV for this buffer
    - `void SyncToGPU()` - Explicitly syncs CPU changes to GPU
    - `void SyncFromGPU()` - Explicitly syncs GPU changes to CPU
  - Key members:
    - `FStructuredBufferRHIRef GPUBuffer` - GPU buffer resource
    - `FShaderResourceViewRHIRef SRV` - Shader resource view
    - `void* CPUBuffer` - CPU accessible buffer pointer
    - `FName BufferName` - Name of the buffer
    - `uint64 SizeInBytes` - Size of the buffer in bytes
    - `bool bIsGPUWritable` - Whether GPU can write to this buffer
    - `bool bIsMapped` - Whether buffer is currently mapped
    - `uint32 ReferenceCount` - Reference counter
    - `uint64 VersionNumber` - Version counter

- `FSharedBufferManager` [2_MemoryManagement/Public/SharedBufferManager.h]: Implements IBufferProvider
  - Purpose: Manages shared buffers between CPU and GPU with explicit synchronization
  - Key methods:
    - Implementation of IBufferProvider interface
    - Double-buffering for asynchronous updates
    - Versioning for change detection
  - Key members:
    - Buffer version tracking
    - Synchronization primitives

- `ICompressionUtility` [2_MemoryManagement/Public/Interfaces/ICompressionUtility.h]: Interface
  - Purpose: Provides compression and decompression utilities for memory optimization
  - Key methods:
    - `bool Compress(const void* UncompressedData, uint64 UncompressedSize, void* CompressedBuffer, uint64& CompressedSize, ECompressionLevel CompressionLevel)` - Compresses data
    - `bool Decompress(const void* CompressedData, uint64 CompressedSize, void* UncompressedBuffer, uint64 UncompressedSize)` - Decompresses data
    - `uint64 GetMaxCompressedSize(uint64 UncompressedSize)` - Gets max compression buffer size needed

- `FCompressionUtility` [2_MemoryManagement/Public/CompressionUtility.h]: Implements ICompressionUtility
  - Purpose: Concrete implementation of compression utilities
  - Key methods:
    - Implementation of ICompressionUtility interface
    - Various compression algorithm implementations

### Structures
- `FMemoryAllocationInfo` [2_MemoryManagement/Public/Interfaces/IMemoryTracker.h]
  - Purpose: Memory allocation tracker entry for detailed monitoring
  - Key members:
    - `void* Ptr` - Pointer to allocated memory
    - `uint64 SizeInBytes` - Size of allocation in bytes
    - `FName CategoryName` - Category for budget tracking
    - `FName AllocationName` - Name for the allocation (optional)
    - `double TimeStamp` - Time when allocation was made
    - `TArray<FString> CallStack` - Call stack for the allocation if tracking enabled
    - `EMemoryTier MemoryTier` - Memory tier classification

- `FMemoryStats` [2_MemoryManagement/Public/Interfaces/IMemoryTracker.h]
  - Purpose: Structure containing memory usage statistics
  - Key members:
    - `uint64 TotalAllocatedBytes` - Total allocated memory in bytes
    - `uint64 AllocationCount` - Total number of allocations
    - `uint64 PeakMemoryUsage` - Peak memory usage in bytes
    - `TMap<FName, uint64> UsageByCategory` - Map of memory usage by category
    - `TMap<FName, uint64> BudgetByCategory` - Map of memory budgets by category
    - `TMap<EMemoryTier, uint64> UsageByTier` - Map of memory usage by tier

- `FSVOSDFMemoryMetrics` [2_MemoryManagement/Public/Interfaces/IMemoryTracker.h]
  - Purpose: Structure containing SVO+SDF specific memory metrics
  - Key members:
    - `uint64 SVONodeMemory` - Memory used by SVO octree nodes in bytes
    - `uint64 SDFFieldMemory` - Memory used by SDF field data in bytes
    - `uint64 NarrowBandMemory` - Memory used by narrow-band high precision data
    - `uint64 MeshDataMemory` - Memory used by mesh data derived from SVO+SDF
    - `uint64 StructureOverheadMemory` - Memory overhead for spatial data structures
    - `float CompressionRatio` - Compression ratio (uncompressed/compressed)

- `FPoolStats` [2_MemoryManagement/Public/Interfaces/IPoolAllocator.h]
  - Purpose: Structure containing information about a memory pool's current state
  - Key members:
    - `FName PoolName` - Name of the pool
    - `uint32 BlockSize` - Size of each block in bytes
    - `uint32 BlockCount` - Number of blocks in the pool
    - `uint32 AllocatedBlocks` - Number of allocated blocks
    - `uint32 FreeBlocks` - Number of free blocks
    - `uint64 TotalAllocations` - Total number of allocation requests
    - `float FragmentationPercent` - Fragmentation percentage (0-100)

- `FBufferStats` [2_MemoryManagement/Public/Interfaces/IBufferProvider.h]
  - Purpose: Structure containing information about a buffer's current state
  - Key members:
    - `FName BufferName` - Name of the buffer
    - `uint64 SizeInBytes` - Size of the buffer in bytes
    - `uint32 ReferenceCount` - Number of active references to the buffer
    - `bool bIsMapped` - Whether buffer is currently mapped for CPU access
    - `bool bIsZeroCopy` - Whether buffer allows zero-copy access
    - `bool bIsGPUWritable` - Whether the buffer can be written to from GPU
    - `uint64 VersionNumber` - Current version number of the buffer
    - `uint64 MapCount` - Number of map operations performed
    - `uint64 UnmapCount` - Number of unmap operations performed
    - `EBufferAccessMode LastAccessMode` - Last access mode used for mapping
    - `EBufferUsage UsageHint` - Usage hint for the buffer

### Enumerations
- `EMemoryAccessPattern` [2_MemoryManagement/Public/Interfaces/IMemoryManager.h]
  - Purpose: Memory access patterns for optimizing allocation strategies
  - Values:
    - `General` - General purpose memory access pattern
    - `Sequential` - Sequential memory access pattern
    - `Random` - Random memory access pattern
    - `Mining` - Mining operation specific access pattern
    - `SDFOperation` - SDF operation specific access pattern
    - `OctreeTraversal` - Octree traversal specific access pattern

- `EMemoryPriority` [2_MemoryManagement/Public/Interfaces/IMemoryManager.h]
  - Purpose: Memory allocation priority levels for resource management
  - Values:
    - `Critical` - Critical priority, must not fail
    - `High` - High priority, important for system operation
    - `Normal` - Normal priority, standard allocations
    - `Low` - Low priority, can be sacrificed under pressure
    - `Cacheable` - Cacheable memory, can be freed and regenerated

- `EMemoryTier` [2_MemoryManagement/Public/Interfaces/IMemoryManager.h]
  - Purpose: Memory tier classifications for hierarchical memory management
  - Values:
    - `Hot` - Frequently accessed memory (highest performance)
    - `Warm` - Moderately accessed memory
    - `Cold` - Infrequently accessed memory
    - `Archive` - Rarely accessed memory (lowest performance)

- `EBufferAccessMode` [2_MemoryManagement/Public/Interfaces/IBufferProvider.h]
  - Purpose: Buffer access modes for determining memory visibility
  - Values:
    - `ReadOnly` - Read-only access to the buffer
    - `WriteOnly` - Write-only access to the buffer
    - `ReadWrite` - Read-write access to the buffer

- `EBufferUsage` [2_MemoryManagement/Public/Interfaces/IBufferProvider.h]
  - Purpose: Buffer usage hints for optimizing memory layout and access patterns
  - Values:
    - `General` - General purpose buffer with balanced characteristics
    - `SDFField` - Buffer optimized for SDF field data storage
    - `SVONodes` - Buffer optimized for SVO octree node storage
    - `MaterialChannels` - Buffer optimized for material channel data
    - `VertexData` - Buffer optimized for vertex data
    - `IndexData` - Buffer optimized for index data

- `ECompressionLevel` [2_MemoryManagement/Public/Interfaces/ICompressionUtility.h]
  - Purpose: Compression level settings for balancing speed vs. size
  - Values:
    - `None` - No compression
    - `Fast` - Fast compression with moderate ratio
    - `Default` - Balanced compression
    - `Maximum` - Maximum compression ratio at cost of speed

### Navigation Landmarks
FileStructure: [2_MemoryManagement/Public/MemoryPoolManager.h]
- Memory pool manager class declaration: ~L15-150
- Default memory budgets: ~L45-50
- Memory pressure thresholds: ~L52-53

FileStructure: [2_MemoryManagement/Private/MemoryPoolManager.cpp]
- Constructor and destructor: ~L23-50
- Initialization and shutdown: ~L52-109
- Pool creation and management: ~L111-189
- Buffer management: ~L191-250
- Memory allocation/deallocation: ~L252-290
- Memory budget management: ~L292-350
- Memory tracking: ~L352-400

FileStructure: [2_MemoryManagement/Public/Interfaces/IMemoryManager.h]
- Memory access pattern enum: ~L15-35
- Memory priority enum: ~L40-60
- Memory tier enum: ~L65-85
- Memory manager interface declaration: ~L90-200

FileStructure: [2_MemoryManagement/Public/Interfaces/IMemoryTracker.h]
- Memory allocation info structure: ~L15-60
- Memory stats structure: ~L65-120
- SVO+SDF memory metrics structure: ~L125-170
- Memory tracker interface: ~L175-250

FileStructure: [2_MemoryManagement/Public/Interfaces/IBufferProvider.h]
- Buffer access mode enum: ~L15-30
- Buffer usage enum: ~L35-60
- Buffer stats structure: ~L65-100
- Buffer provider interface: ~L105-220

FileStructure: [2_MemoryManagement/Public/Interfaces/IPoolAllocator.h]
- Pool stats structure: ~L15-50
- Pool allocator interface: ~L55-175

FileStructure: [2_MemoryManagement/Public/ZeroCopyBuffer.h]
- Zero-copy buffer class declaration: ~L15-120
- GPU buffer integration: ~L125-175

FileStructure: [2_MemoryManagement/Public/SVOAllocator.h]
- SVO allocator class declaration: ~L15-90
- SVO-specific allocation optimizations: ~L95-150

### Implementation Patterns
- Memory Management: Hierarchical memory tiers (Hot, Warm, Cold, Archive) for performance optimization
- Reference Counting: Used for buffer management with AddRef/Release pattern to track usage
- Defragmentation: Time-bounded defragmentation operations with priority levels
- Statistics Tracking: Comprehensive metrics for memory usage by category, tier, and type
- Zero-Copy Buffers: Support for efficient CPU/GPU data sharing with minimal synchronization
- Memory Pools: Block-based allocation for specialized use cases with type-specific optimization
- Thread Safety: Read-write locks, critical sections, and atomic operations for thread-safe memory management
- Memory Budgets: Category-specific memory budgets to prevent resource exhaustion
- Memory Pressure: Progressive response to memory pressure conditions
- NUMA Awareness: Support for NUMA-aware memory allocation on platforms that support it

### UE5 Integration
- Uses UE5 RHI (Rendering Hardware Interface) for GPU buffer management
- Integrates with UE5 memory management primitives like FMalloc
- Utilizes UE5 threading primitives (FRWLock, FCriticalSection) for thread safety
- Leverages UE5 smart pointers (TSharedPtr, TSharedRef) for resource management
- Follows UE5 naming conventions and API patterns

### Potential Conflicts
- Multiple Initialize/Shutdown methods across different interfaces with similar signatures
- Multiple GetStats() methods returning different structure types depending on context
- Similar naming conventions for memory-related methods across different interfaces
- Potential confusion between general memory allocation and pool-based allocation
- Overlapping responsibility between IMemoryManager and more specialized allocators
- Multiple buffer provider implementations with different performance characteristics

### Known Issues & Constraints
- Memory mapping might not be available on all platforms with same performance characteristics
- Prediction accuracy depends on the quality of the cave network topology information
- Frame budgeting must be carefully tuned to avoid hitches during hibernation/reactivation
- Incremental operations might leave the system in temporary inconsistent states between frames
- Complex interdependencies between hibernation, compression, and streaming systems