# Mining System Knowledge Base

This document serves as a comprehensive reference for the Mining System architecture, cataloging key interfaces, classes, methods, and implementation patterns to maintain architectural integrity and prevent name collisions.

IMPORTANT: How to make new files? USE THIS COMMAND -> powershell -Command "Set-Content -Path 'c:\MiningSpiceCoPilot\Source\MiningSpiceCoPilot\filename' -Value '// filename'"

## SYSTEM 1: Core Registry and Type System

### Class Hierarchy
- `IRegistry` [1_CoreRegistry/Public/Interfaces/IRegistry.h]: Interface
  - Purpose: Defines core functionality for type registration, lookup, and management
  - Key methods:
    - `bool Initialize()` - Initializes the registry
    - `void Shutdown()` - Shuts down the registry and cleans up resources
    - `bool IsInitialized() const` - Checks initialization status
    - `FName GetRegistryName() const` - Gets the name of this registry
    - `uint32 GetSchemaVersion() const` - Gets the schema version
    - `bool Validate(TArray<FString>& OutErrors) const` - Validates registry consistency
    - `void Clear()` - Clears all registrations and resets the registry

- `IServiceLocator` [1_CoreRegistry/Public/Interfaces/IServiceLocator.h]: Interface
  - Purpose: Provides service registration, resolution, and lifecycle management for subsystems
  - Key methods:
    - `bool RegisterService(void* InService, const UClass* InInterfaceType, int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE)` - Registers a service implementation
    - `void* ResolveService(const UClass* InInterfaceType, int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE)` - Resolves a service instance
    - `bool UnregisterService(const UClass* InInterfaceType, int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE)` - Unregisters a service implementation
    - `bool HasService(const UClass* InInterfaceType, int32 InZoneID = INDEX_NONE, int32 InRegionID = INDEX_NONE) const` - Checks if a service is registered
    - Template methods for typed service operations
    - `static IServiceLocator& Get()` - Gets the singleton instance

- `IServiceProvider` [1_CoreRegistry/Public/Interfaces/IServiceProvider.h]: Interface
  - Purpose: Interface for classes that provide services to the system
  - Key methods:
    - `void RegisterServices()` - Registers all services provided by this provider
    - `void UnregisterServices()` - Unregisters all services provided by this provider

- `FServiceLocator` [1_CoreRegistry/Public/ServiceLocator.h]: Implements IServiceLocator
  - Purpose: Service registration and resolution for the mining subsystems
  - Key methods:
    - `bool Initialize()` - Initialize the service locator
    - `void Shutdown()` - Shutdown and cleanup resources
    - Implementation of IServiceLocator interface methods
    - `static FServiceLocator& Get()` - Gets the singleton instance
  - Key members:
    - `TMap<FName, void*> ServiceMap` - Map of registered services with context-specific keys
    - `FThreadSafeBool bIsInitialized` - Thread-safe initialization flag
    - `FSpinLock ServiceMapLock` - Lock for thread-safe access to the service map
    - `FName CreateServiceKey(const UClass* InInterfaceType, int32 InZoneID, int32 InRegionID) const` - Creates unique service lookup keys

- `FZoneTypeRegistry` [1_CoreRegistry/Public/ZoneTypeRegistry.h]: Implements IRegistry
  - Purpose: Handles transaction type registration, zone configuration, and concurrency metadata
  - Key methods:
    - IRegistry interface implementation
    - `uint32 RegisterTransactionType(const FName& InTypeName, ETransactionConcurrency InConcurrencyLevel, ERetryStrategy InRetryStrategy)` - Registers a new zone transaction type
    - `uint32 RegisterMaterialTransaction(const FName& InTypeName, int32 InMaterialChannelId)` - Registers a material-specific transaction
    - `bool RegisterZoneGridConfig(const FName& InConfigName, float InZoneSize, uint32 InMaxConcurrentTransactions)` - Registers a zone grid configuration
    - `const FZoneTransactionTypeInfo* GetTransactionTypeInfo(uint32 InTypeId) const` - Gets transaction type info
    - `const FZoneTransactionTypeInfo* GetTransactionTypeInfoByName(const FName& InTypeName) const` - Gets transaction type by name
    - `const FZoneGridConfig* GetZoneGridConfig(const FName& InConfigName) const` - Gets zone grid config
    - `const FZoneGridConfig* GetDefaultZoneGridConfig() const` - Gets default zone grid configuration
    - `bool SetDefaultZoneGridConfig(const FName& InConfigName)` - Sets default zone grid configuration
    - `bool UpdateTransactionProperty(uint32 InTypeId, const FName& InPropertyName, const FString& InValue)` - Updates transaction properties
    - `bool UpdateFastPathThreshold(uint32 InTypeId, float InConflictRate)` - Updates fast-path threshold based on conflict history
    - `bool IsTransactionTypeRegistered(uint32 InTypeId) const` - Checks if a transaction type is registered
    - `bool IsTransactionTypeRegistered(const FName& InTypeName) const` - Checks if a transaction type is registered by name
    - `static FZoneTypeRegistry& Get()` - Gets the singleton instance
  - Key members:
    - `TMap<uint32, TSharedRef<FZoneTransactionTypeInfo>> TransactionTypeMap` - Map of registered transaction types by ID
    - `TMap<FName, uint32> TransactionTypeNameMap` - Map of registered transaction types by name
    - `TMap<FName, TSharedRef<FZoneGridConfig>> ZoneGridConfigMap` - Map of registered zone grid configurations
    - `FName DefaultZoneGridConfigName` - Default zone grid configuration name
    - `uint32 NextTypeId` - Counter for generating unique type IDs
    - `FThreadSafeBool bIsInitialized` - Thread-safe initialization flag
    - `uint32 SchemaVersion` - Schema version of this registry
    - `FSpinLock RegistryLock` - Lock for thread-safe access to registry maps

- `FSVOTypeRegistry` [1_CoreRegistry/Public/SVOTypeRegistry.h]: Implements IRegistry
  - Purpose: Handles type registration, node classification, and memory layout management for SVO nodes
  - Key methods:
    - IRegistry interface implementation
    - `uint32 RegisterNodeType(const FName& InTypeName, ESVONodeClass InNodeClass, uint32 InDataSize, uint32 InAlignmentRequirement, bool bInSupportsMaterialRelationships)` - Registers a new SVO node type
    - `const FSVONodeTypeInfo* GetNodeTypeInfo(uint32 InTypeId) const` - Gets node type info
    - `const FSVONodeTypeInfo* GetNodeTypeInfoByName(const FName& InTypeName) const` - Gets node type by name
    - `TArray<FSVONodeTypeInfo> GetAllNodeTypes() const` - Gets all registered node types
    - `TArray<FSVONodeTypeInfo> GetNodeTypesByClass(ESVONodeClass InNodeClass) const` - Gets nodes by class
    - `bool IsNodeTypeRegistered(uint32 InTypeId) const` - Checks if a node type is registered
    - `bool IsNodeTypeRegistered(const FName& InTypeName) const` - Checks if a node type is registered by name
    - `static FSVOTypeRegistry& Get()` - Gets the singleton instance
  - Key members:
    - `TMap<uint32, TSharedRef<FSVONodeTypeInfo>> NodeTypeMap` - Map of registered node types by ID
    - `TMap<FName, uint32> NodeTypeNameMap` - Map of registered node types by name for lookup
    - `uint32 NextTypeId` - Counter for generating unique type IDs
    - `FThreadSafeBool bIsInitialized` - Thread-safe initialization flag
    - `uint32 SchemaVersion` - Schema version of this registry
    - `FSpinLock RegistryLock` - Lock for thread-safe access

- `FSDFTypeRegistry` [1_CoreRegistry/Public/SDFTypeRegistry.h]: Implements IRegistry
  - Purpose: Handles field type registration, operation compatibility, and evaluation strategies
  - Key methods:
    - IRegistry interface implementation
    - `uint32 RegisterFieldType(const FName& InTypeName, uint32 InChannelCount, bool bInSupportsNarrowBand)` - Registers a new SDF field type
    - `uint32 RegisterFieldOperation(const FName& InOperationName, ESDFOperationType InOperationType, const TArray<uint32>& InCompatibleFieldTypes)` - Registers a new field operation
    - `const FSDFFieldTypeInfo* GetFieldTypeInfo(uint32 InTypeId) const` - Gets field type info
    - `const FSDFFieldTypeInfo* GetFieldTypeInfoByName(const FName& InTypeName) const` - Gets field type by name
    - `const FSDFOperationInfo* GetFieldOperationInfo(uint32 InOperationId) const` - Gets operation info
    - `const FSDFOperationInfo* GetFieldOperationInfoByName(const FName& InOperationName) const` - Gets operation by name
    - `TArray<FSDFFieldTypeInfo> GetAllFieldTypes() const` - Gets all field types
    - `TArray<FSDFOperationInfo> GetAllFieldOperations() const` - Gets all field operations
    - `TArray<FSDFOperationInfo> GetCompatibleOperations(uint32 InTypeId) const` - Gets operations compatible with a field type
    - `bool IsOperationCompatible(uint32 InOperationId, uint32 InTypeId) const` - Checks operation compatibility
    - `bool IsFieldTypeRegistered(uint32 InTypeId) const` - Checks if field type is registered
    - `bool IsFieldOperationRegistered(uint32 InOperationId) const` - Checks if operation is registered
    - `static FSDFTypeRegistry& Get()` - Gets the singleton instance
  - Key members:
    - `TMap<uint32, TSharedRef<FSDFFieldTypeInfo>> FieldTypeMap` - Map of registered field types
    - `TMap<FName, uint32> FieldTypeNameMap` - Map of field types by name
    - `TMap<uint32, TSharedRef<FSDFOperationInfo>> OperationMap` - Map of registered operations
    - `TMap<FName, uint32> OperationNameMap` - Map of operations by name
    - `uint32 NextTypeId` - Counter for generating unique type IDs
    - `uint32 NextOperationId` - Counter for generating unique operation IDs

- `FMaterialRegistry` [1_CoreRegistry/Public/MaterialRegistry.h]: Implements IRegistry
  - Purpose: Handles material type registration, properties, and relationships
  - Key methods:
    - IRegistry interface implementation
    - `uint32 RegisterMaterialType(const FName& InTypeName, EMaterialPriority InPriority, const FName& InParentTypeName)` - Registers a new material type
    - `uint32 RegisterMaterialRelationship(const FName& InSourceTypeName, const FName& InTargetTypeName, float InCompatibilityScore, bool bInCanBlend)` - Registers material relationships
    - `int32 AllocateMaterialChannel(uint32 InTypeId)` - Allocates a channel ID for materials
    - `const FMaterialTypeInfo* GetMaterialTypeInfo(uint32 InTypeId) const` - Gets material type info
    - `const FMaterialTypeInfo* GetMaterialTypeInfoByName(const FName& InTypeName) const` - Gets material type by name
    - `const FMaterialRelationship* GetMaterialRelationship(uint32 InRelationshipId) const` - Gets relationship info
    - `TArray<FMaterialTypeInfo> GetAllMaterialTypes() const` - Gets all material types
    - `TArray<FMaterialTypeInfo> GetDerivedMaterialTypes(uint32 InParentTypeId) const` - Gets derived material types
    - `TArray<FMaterialRelationship> GetMaterialRelationships(uint32 InTypeId) const` - Gets relationships for a material
    - `bool IsMaterialTypeRegistered(uint32 InTypeId) const` - Checks if material is registered
    - `bool IsMaterialTypeRegistered(const FName& InTypeName) const` - Checks if material is registered by name
    - `bool IsMaterialDerivedFrom(uint32 InDerivedTypeId, uint32 InBaseTypeId) const` - Checks material inheritance
    - `bool UpdateMaterialProperty(uint32 InTypeId, const FName& InPropertyName, const FString& InValue)` - Updates material properties
    - `static FMaterialRegistry& Get()` - Gets the singleton instance
  - Key members:
    - `TMap<uint32, TSharedRef<FMaterialTypeInfo>> MaterialTypeMap` - Map of registered material types
    - `TMap<FName, uint32> MaterialTypeNameMap` - Map of material types by name
    - `TMap<uint32, TSharedRef<FMaterialRelationship>> RelationshipMap` - Map of material relationships
    - `TMultiMap<uint32, uint32> RelationshipsBySourceMap` - Relationships indexed by source type
    - `TMultiMap<uint32, uint32> RelationshipsByTargetMap` - Relationships indexed by target type
    - `TMap<uint32, TArray<uint32>> MaterialHierarchyMap` - Material type inheritance hierarchy
    - `TSet<int32> AllocatedChannelIds` - Set of allocated material channel IDs
    - `uint32 NextTypeId` - Counter for generating unique type IDs
    - `uint32 NextRelationshipId` - Counter for generating unique relationship IDs
    - `int32 NextChannelId` - Counter for generating unique channel IDs

### Structures
- `FZoneTransactionTypeInfo` [1_CoreRegistry/Public/ZoneTypeRegistry.h]
  - Purpose: Metadata for zone transaction types
  - Key members:
    - `uint32 TypeId` - Unique ID for this transaction type
    - `FName TypeName` - Name of this transaction type
    - `ETransactionConcurrency ConcurrencyLevel` - Concurrency level for this transaction type
    - `ERetryStrategy RetryStrategy` - Retry strategy for conflicts
    - `uint32 MaxRetries` - Maximum number of retry attempts
    - `uint32 BaseRetryIntervalMs` - Base retry interval in milliseconds
    - `int32 MaterialChannelId` - Material channel ID for material-specific transactions
    - `uint32 Priority` - Priority for conflict resolution

- `FZoneGridConfig` [1_CoreRegistry/Public/ZoneTypeRegistry.h]
  - Purpose: Configuration for zone grids in the mining system
  - Key members:
    - `float ZoneSize` - Size of a zone in world units
    - `FName DefaultConfigName` - Default zone configuration name
    - `uint32 MaxConcurrentTransactions` - Maximum number of concurrent transactions per zone
    - `bool bUseMaterialSpecificVersioning` - Whether to use material-specific versioning
    - `uint32 VersionHistoryLength` - Number of versions to track in history

- `FSVONodeTypeInfo` [1_CoreRegistry/Public/SVOTypeRegistry.h]
  - Purpose: Metadata for SVO node types
  - Key members:
    - `uint32 TypeId` - Unique ID for this node type
    - `FName TypeName` - Name of this node type
    - `ESVONodeClass NodeClass` - Class of this node type
    - `uint32 DataSize` - Size of node data in bytes
    - `uint32 AlignmentRequirement` - Memory alignment requirement
    - `bool bSupportsMaterialRelationships` - Whether this node type supports material relationships
    - `bool bSupportsCompression` - Whether this node type supports compression
    - `bool bIsSerializable` - Whether this node type can be serialized
    - `uint32 SchemaVersion` - Version of this node type's schema

- `FSDFFieldTypeInfo` [1_CoreRegistry/Public/SDFTypeRegistry.h]
  - Purpose: Information about SDF field types
  - Key members:
    - `uint32 TypeId` - Unique ID for this field type
    - `FName TypeName` - Name of this field type
    - `uint32 SchemaVersion` - Version of this field type's schema
    - `uint32 ChannelCount` - Number of channels supported by this field type
    - `bool bSupportsNarrowBand` - Whether this field type supports narrow-band optimization
    - `bool bSupportsGPUEvaluation` - Whether this field type supports GPU evaluation
    - `bool bSupportsSIMD` - Whether this field type supports SIMD operations

- `FSDFOperationInfo` [1_CoreRegistry/Public/SDFTypeRegistry.h]
  - Purpose: Information about SDF field operations
  - Key members:
    - `uint32 OperationId` - Unique ID for this operation
    - `FName OperationName` - Name of this operation
    - `ESDFOperationType OperationType` - Type of this operation
    - `TArray<uint32> CompatibleFieldTypes` - Field types that this operation is compatible with
    - `TArray<uint32> CompatibleMaterialTypes` - Material types that this operation is compatible with
    - `bool bSupportsGPUEvaluation` - Whether this operation supports GPU evaluation
    - `bool bSupportsSIMD` - Whether this operation supports SIMD operations
    - `float ComputationalCost` - Approximate computational cost (normalized value)

- `FMaterialTypeInfo` [1_CoreRegistry/Public/MaterialRegistry.h]
  - Purpose: Metadata for material types
  - Key members:
    - `uint32 TypeId` - Unique ID for this material type
    - `FName TypeName` - Name of this material type
    - `uint32 ParentTypeId` - Parent material type ID, 0 if none
    - `EMaterialPriority Priority` - Priority level for this material
    - `float ResourceValueMultiplier` - Resource value multiplier
    - `float BaseMiningResistance` - Base resistance to mining operations
    - `float SoundAmplificationFactor` - Base sound amplification factor
    - `float ParticleEmissionMultiplier` - Base particle emission rate multiplier
    - `bool bIsMineable` - Whether this material is mineable
    - `bool bIsResource` - Whether this material is valuable as a resource
    - `bool bCanFracture` - Whether this material can fracture
    - `int32 ChannelId` - Channel ID for this material in multi-channel SDF fields

- `FMaterialRelationship` [1_CoreRegistry/Public/MaterialRegistry.h]
  - Purpose: Relationship between material types
  - Key members:
    - `uint32 RelationshipId` - Unique ID for this relationship
    - `uint32 SourceTypeId` - Source material type ID
    - `uint32 TargetTypeId` - Target material type ID
    - `float CompatibilityScore` - Relationship compatibility score (0-1)
    - `bool bCanBlend` - Whether materials can blend at boundaries
    - `float BlendSharpness` - Boundary sharpness when blending (0-1)

### Enumerations
- `ETransactionConcurrency` [1_CoreRegistry/Public/ZoneTypeRegistry.h]
  - Purpose: Transaction concurrency level for zone operations
  - Values: ReadOnly, Optimistic, Exclusive, MaterialChannel

- `ERetryStrategy` [1_CoreRegistry/Public/ZoneTypeRegistry.h]
  - Purpose: Retry strategy type for transaction conflicts
  - Values: None, FixedInterval, ExponentialBackoff, Custom

- `ESVONodeClass` [1_CoreRegistry/Public/SVOTypeRegistry.h]
  - Purpose: SVO node class types for classification
  - Values: Homogeneous, Interface, Empty, Custom

- `ESDFOperationType` [1_CoreRegistry/Public/SDFTypeRegistry.h]
  - Purpose: SDF field operation types for CSG operations
  - Values: Union, Subtraction, Intersection, SmoothUnion, SmoothSubtraction, SmoothIntersection, Custom

- `ESDFEvaluationContext` [1_CoreRegistry/Public/SDFTypeRegistry.h]
  - Purpose: SDF field evaluation contexts
  - Values: Mining, Rendering, Physics, GameLogic

- `EMaterialPriority` [1_CoreRegistry/Public/MaterialRegistry.h]
  - Purpose: Material priority levels for interaction conflicts
  - Values: Low, Normal, High, Critical

### Navigation Landmarks
FileStructure: [1_CoreRegistry/Public/Interfaces/IRegistry.h]
- Registry interface declaration: ~L12-56

FileStructure: [1_CoreRegistry/Public/Interfaces/IServiceLocator.h]
- Service locator interface declaration: ~L12-104

FileStructure: [1_CoreRegistry/Public/Interfaces/IServiceProvider.h]
- Service provider interface declaration: ~L12-40

FileStructure: [1_CoreRegistry/Public/ServiceLocator.h]
- Service locator implementation: ~L12-55

FileStructure: [1_CoreRegistry/Public/ZoneTypeRegistry.h]
- Transaction concurrency enum: ~L13-24
- Retry strategy enum: ~L29-39
- Transaction type info structure: ~L44-73
- Zone grid config structure: ~L78-90
- Zone type registry implementation: ~L101-256

FileStructure: [1_CoreRegistry/Public/SVOTypeRegistry.h]
- Node class enum: ~L13-23
- Node type info structure: ~L32-51
- SVO type registry implementation: ~L56-143

FileStructure: [1_CoreRegistry/Public/SDFTypeRegistry.h]
- Operation type enum: ~L16-28
- Evaluation context enum: ~L33-43
- Field type info structure: ~L58-84
- Operation info structure: ~L89-101
- SDF type registry implementation: ~L112-228

FileStructure: [1_CoreRegistry/Public/MaterialRegistry.h]
- Material priority enum: ~L16-26
- Material type info structure: ~L39-77
- Material relationship structure: ~L82-95
- Material registry implementation: ~L97-197

FileStructure: [1_CoreRegistry/Private/MaterialRegistry.cpp]
- Constructor and destructor: ~L5-12
- Initialization and shutdown: ~L15-25
- Material type registration: ~L82-119
- Material relationship registration: ~L122-163
- Material property management: ~L166-201
- Memory management and thread safety: ~L205-243

### Implementation Patterns
- Singleton Pattern: All registries implement a singleton pattern with thread-safe initialization
  ```cpp
  static FRegistryType& Get();
  static FRegistryType* Singleton;
  static FThreadSafeBool bSingletonInitialized;
  ```

- Thread Safety: Thread-safe access to registries using spin locks
  ```cpp
  mutable FSpinLock RegistryLock;
  FThreadSafeBool bIsInitialized;
  ```

- Type Registration: Standard pattern for registering types with unique IDs
  ```cpp
  uint32 RegisterXXX(const FName& InTypeName, ...);
  uint32 GenerateUniqueTypeId();
  ```

- Metadata Structures: Rich metadata associated with each registered type
  ```cpp
  struct FXXXTypeInfo { uint32 TypeId; FName TypeName; ... };
  ```

- Fast Lookup: Both ID-based and name-based lookup mechanisms
  ```cpp
  TMap<uint32, TSharedRef<FTypeInfo>> TypeMap;
  TMap<FName, uint32> TypeNameMap;
  ```

- Schema Versioning: Registry schema versions for compatibility and migration
  ```cpp
  uint32 GetSchemaVersion() const override;
  uint32 SchemaVersion;
  ```

- Validation: Registry validation to ensure data consistency
  ```cpp
  bool Validate(TArray<FString>& OutErrors) const override;
  ```

- Relationship Management: Two-way relationship tracking with multi-maps
  ```cpp
  TMultiMap<uint32, uint32> RelationshipsBySourceMap;
  TMultiMap<uint32, uint32> RelationshipsByTargetMap;
  ```

### UE5 Integration
- UINTERFACE and GENERATED_BODY macros for UE5 reflection
- MININGSPICECOPILOT_API macro for proper DLL export
- UObject integration for interface reflection and blueprint exposure
- UE5 containers (TMap, TArray, TSet, TSharedRef) used throughout
- UE5 thread safety primitives (FThreadSafeBool, FSpinLock) for concurrency

### Naming Patterns
- Registry classes: Prefix with 'F' (FZoneTypeRegistry, FMaterialRegistry)
- Registry interfaces: Prefix with 'I' (IRegistry, IServiceLocator)
- Type information structs: Suffix with 'TypeInfo' (FZoneTransactionTypeInfo)
- Enumerations: Prefix with 'E' (ETransactionConcurrency)
- Registration methods: Prefix with 'Register' (RegisterTransactionType)
- Getter methods: Prefix with 'Get' (GetTransactionTypeInfo)
- Boolean check methods: Prefix with 'Is' (IsTransactionTypeRegistered)
- Method parameters: Prefix with 'In' for inputs (InTypeName, InTypeId)

### Potential Conflicts
- Multiple `Register` methods with similar signatures across different registries
  - `RegisterXXXType` appears in multiple registries with different parameter patterns
  - `RegisterYYYRelationship` appears in multiple registries with different parameter patterns

- Similar getter methods that return slightly different info types
  - `GetXXXTypeInfo` in different registries return different struct types
  - `GetXXXTypeInfoByName` in different registries with identical signatures

- Boolean check methods with similar names
  - `IsXXXTypeRegistered(uint32)` and `IsXXXTypeRegistered(FName)` overloaded in multiple registries

- Multiple singleton Get() methods with the same name but different return types

### Architectural Boundaries
- Core Registry System provides type registration and lookup services for other systems
- Service Locator allows for dependency injection and system decoupling
- Registry types (Material, Zone, SVO, SDF) connect to their respective subsystems
- Clear separation between registration concerns and implementation concerns

### Dependencies
- Depends on UE5 Core (CoreMinimal.h, UObject)
- Required by most other systems for type resolution and service location
- Provides foundational type system for SVO+SDF mining architecture

## SYSTEM 2: Memory Management System

### Class Hierarchy
- `IMemoryManager` [2_MemoryManagement/Public/Interfaces/IMemoryManager.h]: Interface
  - Purpose: Provides comprehensive memory management capabilities optimized for mining operations
  - Key methods:
    - `bool Initialize()` - Initializes the memory manager
    - `void Shutdown()` - Shuts down the memory manager and cleans up resources
    - `bool IsInitialized() const` - Checks initialization status
    - `IPoolAllocator* CreatePool(const FName& PoolName, uint32 BlockSize, uint32 BlockCount, EMemoryAccessPattern AccessPattern, bool bAllowGrowth)` - Creates a memory pool with specified characteristics
    - `IPoolAllocator* GetPool(const FName& PoolName) const` - Gets a pool allocator by name
    - `IBufferProvider* CreateBuffer(const FName& BufferName, uint64 SizeInBytes, bool bZeroCopy, bool bGPUWritable)` - Creates a shared buffer for CPU/GPU operations
    - `IBufferProvider* GetBuffer(const FName& BufferName) const` - Gets a buffer provider by name
    - `IMemoryTracker* GetMemoryTracker() const` - Gets the memory tracker for telemetry
    - `bool DefragmentMemory(float MaxTimeMs, EMemoryPriority Priority)` - Performs memory defragmentation
    - `void* Allocate(uint64 SizeInBytes, uint32 Alignment = 16)` - Allocates memory from the general heap
    - `void Free(void* Ptr)` - Frees memory previously allocated with Allocate
    - `void SetMemoryBudget(const FName& CategoryName, uint64 BudgetInBytes)` - Sets memory budget for a category
    - `uint64 GetMemoryBudget(const FName& CategoryName) const` - Gets memory budget for a category
    - `uint64 GetMemoryUsage(const FName& CategoryName) const` - Gets memory usage for a category
    - `void RegisterAllocation(void* Ptr, uint64 SizeInBytes, const FName& CategoryName, const FName& AllocationName)` - Registers a memory allocation for tracking
    - `void UnregisterAllocation(void* Ptr, const FName& CategoryName)` - Unregisters a memory allocation
    - `bool SetNUMAPolicy(bool bUseNUMAAwareness, int32 PreferredNode)` - Sets NUMA policy for memory allocations
    - `bool IsSupported() const` - Checks if the memory manager is supported on the current platform
    - `static IMemoryManager& Get()` - Gets the singleton instance

- `FMemoryPoolManager` [2_MemoryManagement/Public/MemoryPoolManager.h]: Implements IMemoryManager
  - Purpose: Concrete implementation of the memory manager with specialized allocators for mining operations
  - Key methods:
    - Implementation of IMemoryManager interface
    - `IPoolAllocator* CreateSVONodePool(const FName& PoolName, uint32 NodeSize, uint32 NodeCount)` - Creates a specialized pool for SVO nodes
    - Static memory budget constants:
      - `DEFAULT_BUDGET_SVO_NODES = 256 * 1024 * 1024` - 256 MB for SVO nodes
      - `DEFAULT_BUDGET_SDF_FIELDS = 512 * 1024 * 1024` - 512 MB for SDF fields
      - `DEFAULT_BUDGET_NARROW_BAND = 128 * 1024 * 1024` - 128 MB for narrow band
      - `DEFAULT_BUDGET_MATERIAL_CHANNELS = 256 * 1024 * 1024` - 256 MB for material channels
      - `DEFAULT_BUDGET_MESH_DATA = 128 * 1024 * 1024` - 128 MB for mesh data
      - `DEFAULT_BUDGET_GENERAL = 64 * 1024 * 1024` - 64 MB for general purpose
    - Memory pressure thresholds:
      - `MEMORY_PRESSURE_THRESHOLD = 0.15f` - 15% free memory triggers pressure warning
      - `MEMORY_CRITICAL_THRESHOLD = 0.05f` - 5% free memory triggers critical pressure
  - Key members:
    - `IMemoryTracker* MemoryTracker` - Memory tracking component
    - `IMemoryDefragmenter* Defragmenter` - Memory defragmentation component
    - `TMap<FName, TSharedPtr<IPoolAllocator>> Pools` - Map of memory pools
    - `TMap<FName, TSharedPtr<IBufferProvider>> Buffers` - Map of buffer providers
    - `FRWLock PoolsLock` - Read-write lock for thread-safe pool access
    - `FRWLock BuffersLock` - Read-write lock for thread-safe buffer access
    - `bool bIsInitialized` - Initialization flag
    - `bool bNUMAAwarenessEnabled` - Whether NUMA policy is enabled
    - `int32 NUMAPreferredNode` - Preferred NUMA node when enabled
    - `FCriticalSection SingletonLock` - Lock for singleton access
    - `static FMemoryPoolManager* ManagerInstance` - Singleton instance

- `IMemoryTracker` [2_MemoryManagement/Public/Interfaces/IMemoryTracker.h]: Interface
  - Purpose: Provides memory telemetry and monitoring functionality
  - Key methods:
    - `bool Initialize()` - Initializes the memory tracker
    - `void Shutdown()` - Shuts down the memory tracker and cleans up resources
    - `bool IsInitialized() const` - Checks initialization status
    - `bool TrackAllocation(void* Ptr, uint64 SizeInBytes, const FName& CategoryName, const FName& AllocationName)` - Tracks a memory allocation
    - `bool UntrackAllocation(void* Ptr)` - Untracks a memory allocation
    - `const FMemoryAllocationInfo* GetAllocationInfo(void* Ptr) const` - Gets allocation info
    - `FMemoryStats GetMemoryStats() const` - Gets current memory statistics
    - `FSVOSDFMemoryMetrics GetSVOSDFMemoryMetrics() const` - Gets SVO+SDF specific memory metrics
    - `void SetMemoryBudget(const FName& CategoryName, uint64 BudgetInBytes)` - Sets memory budget
    - `uint64 GetMemoryBudget(const FName& CategoryName) const` - Gets memory budget
    - `uint64 GetMemoryUsage(const FName& CategoryName) const` - Gets memory usage

- `FMemoryTelemetry` [2_MemoryManagement/Public/MemoryTelemetry.h]: Implements IMemoryTracker
  - Purpose: Concrete implementation of memory tracking and telemetry
  - Key methods:
    - Implementation of IMemoryTracker interface
    - Memory usage visualization and reporting functions
    - Memory leak detection and tracking
  - Key members:
    - `TMap<void*, FMemoryAllocationInfo> AllocationsMap` - Map of tracked allocations
    - `TMap<FName, uint64> CategoryBudgets` - Budget for each memory category
    - `TMap<FName, uint64> CategoryUsage` - Current usage for each category
    - `FCriticalSection AllocationLock` - Thread safety for allocation tracking

- `IMemoryDefragmenter` [2_MemoryManagement/Public/Interfaces/IMemoryDefragmenter.h]: Interface
  - Purpose: Provides memory defragmentation functionality to optimize memory layout
  - Key methods:
    - `bool Initialize()` - Initializes the defragmenter
    - `void Shutdown()` - Shuts down the defragmenter
    - `bool IsInitialized() const` - Checks initialization status
    - `bool DefragmentMemory(float MaxTimeMs, EMemoryPriority Priority)` - Performs defragmentation within time budget
    - `bool RegisterPool(IPoolAllocator* Pool)` - Registers a pool for defragmentation
    - `bool UnregisterPool(const FName& PoolName)` - Unregisters a pool
    - `float GetFragmentationPercent() const` - Gets current fragmentation percentage

- `FMemoryDefragmenter` [2_MemoryManagement/Public/MemoryDefragmenter.h]: Implements IMemoryDefragmenter
  - Purpose: Concrete implementation of memory defragmentation
  - Key methods:
    - Implementation of IMemoryDefragmenter interface
    - Time-sliced defragmentation algorithms
    - Priority-based defragmentation scheduling
  - Key members:
    - `TMap<FName, IPoolAllocator*> RegisteredPools` - Map of pools registered for defragmentation
    - `bool bIsDefragmenting` - Whether defragmentation is in progress
    - `FCriticalSection DefragmentationLock` - Thread safety for defragmentation operations

- `IPoolAllocator` [2_MemoryManagement/Public/Interfaces/IPoolAllocator.h]: Interface
  - Purpose: Provides block-based memory allocation optimized for specific use cases
  - Key methods:
    - `bool Initialize()` - Initializes the pool allocator
    - `void Shutdown()` - Shuts down the pool allocator
    - `bool IsInitialized() const` - Checks initialization status
    - `FName GetPoolName() const` - Gets the name of this pool
    - `uint32 GetBlockSize() const` - Gets the block size for this pool
    - `void* Allocate(const UObject* RequestingObject = nullptr, FName AllocationTag = NAME_None)` - Allocates a block
    - `bool Free(void* Ptr)` - Frees a previously allocated block
    - `bool Grow(uint32 AdditionalBlockCount, bool bForceGrowth = false)` - Attempts to grow the pool
    - `uint32 Shrink(uint32 MaxBlocksToRemove = UINT32_MAX)` - Attempts to shrink the pool
    - `bool OwnsPointer(const void* Ptr) const` - Checks if a pointer belongs to this pool
    - `FPoolStats GetStats() const` - Gets current pool statistics
    - `bool Defragment(float MaxTimeMs = 5.0f)` - Performs defragmentation on the pool

- `FSVOAllocator` [2_MemoryManagement/Public/SVOAllocator.h]: Implements IPoolAllocator
  - Purpose: Specialized allocator for SVO (Sparse Voxel Octree) nodes
  - Key methods:
    - Implementation of IPoolAllocator interface
    - Octree-specific allocation optimizations
    - Spatial locality improvements for traversal
  - Key members:
    - `TArray<uint8*> MemoryBlocks` - Array of memory block pointers
    - `TArray<uint32> FreeIndices` - Free block indices for fast allocation
    - `TBitArray<> AllocationMap` - Bitmap of allocated blocks

- `INarrowBandAllocator` [2_MemoryManagement/Public/Interfaces/INarrowBandAllocator.h]: Interface
  - Purpose: Specialized allocator for narrow band SDF data with high precision
  - Key methods:
    - IPoolAllocator interface implementation
    - Narrow band specific allocation methods

- `FNarrowBandAllocator` [2_MemoryManagement/Public/NarrowBandAllocator.h]: Implements INarrowBandAllocator
  - Purpose: Concrete implementation of narrow band allocator for high-precision SDF
  - Key methods:
    - Implementation of INarrowBandAllocator interface
    - Narrow band optimization algorithms
  - Key members:
    - Narrow band width and precision configuration
    - Spatial hashing for efficient lookup

- `IBufferProvider` [2_MemoryManagement/Public/Interfaces/IBufferProvider.h]: Interface
  - Purpose: Provides buffer sharing between CPU and GPU components with efficient synchronization
  - Key methods:
    - `bool Initialize()` - Initializes the buffer provider
    - `void Shutdown()` - Shuts down the buffer provider 
    - `bool IsInitialized() const` - Checks initialization status
    - `FName GetBufferName() const` - Gets the name of this buffer
    - `uint64 GetSizeInBytes() const` - Gets the size of this buffer
    - `void* Map(EBufferAccessMode AccessMode = EBufferAccessMode::ReadWrite)` - Maps buffer for CPU access
    - `bool Unmap()` - Unmaps the buffer, making changes visible to GPU
    - `bool IsMapped() const` - Checks if the buffer is currently mapped
    - `bool Resize(uint64 NewSizeInBytes, bool bPreserveContent = true)` - Resizes the buffer
    - `void* GetGPUResource() const` - Gets underlying GPU resource
    - `void AddRef()` - Adds a reference to this buffer
    - `uint32 Release()` - Releases a reference to this buffer
    - `FBufferStats GetStats() const` - Gets current buffer statistics
    - `void SetUsageHint(EBufferUsage UsageHint)` - Sets usage hint for optimization
    - `EBufferUsage GetUsageHint() const` - Gets current usage hint
    - `bool SupportsZeroCopy() const` - Checks if zero-copy is supported
    - `bool IsGPUWritable() const` - Checks if GPU can write to buffer
    - `uint64 GetVersionNumber() const` - Gets buffer version number

- `FZeroCopyBuffer` [2_MemoryManagement/Public/ZeroCopyBuffer.h]: Implements IBufferProvider
  - Purpose: Zero-copy buffer implementation for GPU/CPU data sharing with minimal synchronization overhead
  - Key methods:
    - Implementation of IBufferProvider interface
    - `FStructuredBufferRHIRef GetRHIBuffer() const` - Gets the RHI structured buffer resource
    - `FShaderResourceViewRHIRef GetShaderResourceView() const` - Gets SRV for this buffer
    - `void SyncToGPU()` - Explicitly syncs CPU changes to GPU
    - `void SyncFromGPU()` - Explicitly syncs GPU changes to CPU
  - Key members:
    - `FStructuredBufferRHIRef GPUBuffer` - GPU buffer resource
    - `FShaderResourceViewRHIRef SRV` - Shader resource view
    - `void* CPUBuffer` - CPU accessible buffer pointer
    - `FName BufferName` - Name of the buffer
    - `uint64 SizeInBytes` - Size of the buffer in bytes
    - `bool bIsGPUWritable` - Whether GPU can write to this buffer
    - `bool bIsMapped` - Whether buffer is currently mapped
    - `uint32 ReferenceCount` - Reference counter
    - `uint64 VersionNumber` - Version counter

- `FSharedBufferManager` [2_MemoryManagement/Public/SharedBufferManager.h]: Implements IBufferProvider
  - Purpose: Manages shared buffers between CPU and GPU with explicit synchronization
  - Key methods:
    - Implementation of IBufferProvider interface
    - Double-buffering for asynchronous updates
    - Versioning for change detection
  - Key members:
    - Buffer version tracking
    - Synchronization primitives

- `ICompressionUtility` [2_MemoryManagement/Public/Interfaces/ICompressionUtility.h]: Interface
  - Purpose: Provides compression and decompression utilities for memory optimization
  - Key methods:
    - `bool Compress(const void* UncompressedData, uint64 UncompressedSize, void* CompressedBuffer, uint64& CompressedSize, ECompressionLevel CompressionLevel)` - Compresses data
    - `bool Decompress(const void* CompressedData, uint64 CompressedSize, void* UncompressedBuffer, uint64 UncompressedSize)` - Decompresses data
    - `uint64 GetMaxCompressedSize(uint64 UncompressedSize)` - Gets max compression buffer size needed

- `FCompressionUtility` [2_MemoryManagement/Public/CompressionUtility.h]: Implements ICompressionUtility
  - Purpose: Concrete implementation of compression utilities
  - Key methods:
    - Implementation of ICompressionUtility interface
    - Various compression algorithm implementations

### Structures
- `FMemoryAllocationInfo` [2_MemoryManagement/Public/Interfaces/IMemoryTracker.h]
  - Purpose: Memory allocation tracker entry for detailed monitoring
  - Key members:
    - `void* Ptr` - Pointer to allocated memory
    - `uint64 SizeInBytes` - Size of allocation in bytes
    - `FName CategoryName` - Category for budget tracking
    - `FName AllocationName` - Name for the allocation (optional)
    - `double TimeStamp` - Time when allocation was made
    - `TArray<FString> CallStack` - Call stack for the allocation if tracking enabled
    - `EMemoryTier MemoryTier` - Memory tier classification

- `FMemoryStats` [2_MemoryManagement/Public/Interfaces/IMemoryTracker.h]
  - Purpose: Structure containing memory usage statistics
  - Key members:
    - `uint64 TotalAllocatedBytes` - Total allocated memory in bytes
    - `uint64 AllocationCount` - Total number of allocations
    - `uint64 PeakMemoryUsage` - Peak memory usage in bytes
    - `TMap<FName, uint64> UsageByCategory` - Map of memory usage by category
    - `TMap<FName, uint64> BudgetByCategory` - Map of memory budgets by category
    - `TMap<EMemoryTier, uint64> UsageByTier` - Map of memory usage by tier

- `FSVOSDFMemoryMetrics` [2_MemoryManagement/Public/Interfaces/IMemoryTracker.h]
  - Purpose: Structure containing SVO+SDF specific memory metrics
  - Key members:
    - `uint64 SVONodeMemory` - Memory used by SVO octree nodes in bytes
    - `uint64 SDFFieldMemory` - Memory used by SDF field data in bytes
    - `uint64 NarrowBandMemory` - Memory used by narrow-band high precision data
    - `uint64 MeshDataMemory` - Memory used by mesh data derived from SVO+SDF
    - `uint64 StructureOverheadMemory` - Memory overhead for spatial data structures
    - `float CompressionRatio` - Compression ratio (uncompressed/compressed)

- `FPoolStats` [2_MemoryManagement/Public/Interfaces/IPoolAllocator.h]
  - Purpose: Structure containing information about a memory pool's current state
  - Key members:
    - `FName PoolName` - Name of the pool
    - `uint32 BlockSize` - Size of each block in bytes
    - `uint32 BlockCount` - Number of blocks in the pool
    - `uint32 AllocatedBlocks` - Number of allocated blocks
    - `uint32 FreeBlocks` - Number of free blocks
    - `uint64 TotalAllocations` - Total number of allocation requests
    - `float FragmentationPercent` - Fragmentation percentage (0-100)

- `FBufferStats` [2_MemoryManagement/Public/Interfaces/IBufferProvider.h]
  - Purpose: Structure containing information about a buffer's current state
  - Key members:
    - `FName BufferName` - Name of the buffer
    - `uint64 SizeInBytes` - Size of the buffer in bytes
    - `uint32 ReferenceCount` - Number of active references to the buffer
    - `bool bIsMapped` - Whether buffer is currently mapped for CPU access
    - `bool bIsZeroCopy` - Whether buffer allows zero-copy access
    - `bool bIsGPUWritable` - Whether the buffer can be written to from GPU
    - `uint64 VersionNumber` - Current version number of the buffer
    - `uint64 MapCount` - Number of map operations performed
    - `uint64 UnmapCount` - Number of unmap operations performed
    - `EBufferAccessMode LastAccessMode` - Last access mode used for mapping
    - `EBufferUsage UsageHint` - Usage hint for the buffer

### Enumerations
- `EMemoryAccessPattern` [2_MemoryManagement/Public/Interfaces/IMemoryManager.h]
  - Purpose: Memory access patterns for optimizing allocation strategies
  - Values:
    - `General` - General purpose memory access pattern
    - `Sequential` - Sequential memory access pattern
    - `Random` - Random memory access pattern
    - `Mining` - Mining operation specific access pattern
    - `SDFOperation` - SDF operation specific access pattern
    - `OctreeTraversal` - Octree traversal specific access pattern

- `EMemoryPriority` [2_MemoryManagement/Public/Interfaces/IMemoryManager.h]
  - Purpose: Memory allocation priority levels for resource management
  - Values:
    - `Critical` - Critical priority, must not fail
    - `High` - High priority, important for system operation
    - `Normal` - Normal priority, standard allocations
    - `Low` - Low priority, can be sacrificed under pressure
    - `Cacheable` - Cacheable memory, can be freed and regenerated

- `EMemoryTier` [2_MemoryManagement/Public/Interfaces/IMemoryManager.h]
  - Purpose: Memory tier classifications for hierarchical memory management
  - Values:
    - `Hot` - Frequently accessed memory (highest performance)
    - `Warm` - Moderately accessed memory
    - `Cold` - Infrequently accessed memory
    - `Archive` - Rarely accessed memory (lowest performance)

- `EBufferAccessMode` [2_MemoryManagement/Public/Interfaces/IBufferProvider.h]
  - Purpose: Buffer access modes for determining memory visibility
  - Values:
    - `ReadOnly` - Read-only access to the buffer
    - `WriteOnly` - Write-only access to the buffer
    - `ReadWrite` - Read-write access to the buffer

- `EBufferUsage` [2_MemoryManagement/Public/Interfaces/IBufferProvider.h]
  - Purpose: Buffer usage hints for optimizing memory layout and access patterns
  - Values:
    - `General` - General purpose buffer with balanced characteristics
    - `SDFField` - Buffer optimized for SDF field data storage
    - `SVONodes` - Buffer optimized for SVO octree node storage
    - `MaterialChannels` - Buffer optimized for material channel data
    - `VertexData` - Buffer optimized for vertex data
    - `IndexData` - Buffer optimized for index data

- `ECompressionLevel` [2_MemoryManagement/Public/Interfaces/ICompressionUtility.h]
  - Purpose: Compression level settings for balancing speed vs. size
  - Values:
    - `None` - No compression
    - `Fast` - Fast compression with moderate ratio
    - `Default` - Balanced compression
    - `Maximum` - Maximum compression ratio at cost of speed

### Navigation Landmarks
FileStructure: [2_MemoryManagement/Public/MemoryPoolManager.h]
- Memory pool manager class declaration: ~L15-150
- Default memory budgets: ~L45-50
- Memory pressure thresholds: ~L52-53

FileStructure: [2_MemoryManagement/Private/MemoryPoolManager.cpp]
- Constructor and destructor: ~L23-50
- Initialization and shutdown: ~L52-109
- Pool creation and management: ~L111-189
- Buffer management: ~L191-250
- Memory allocation/deallocation: ~L252-290
- Memory budget management: ~L292-350
- Memory tracking: ~L352-400

FileStructure: [2_MemoryManagement/Public/Interfaces/IMemoryManager.h]
- Memory access pattern enum: ~L15-35
- Memory priority enum: ~L40-60
- Memory tier enum: ~L65-85
- Memory manager interface declaration: ~L90-200

FileStructure: [2_MemoryManagement/Public/Interfaces/IMemoryTracker.h]
- Memory allocation info structure: ~L15-60
- Memory stats structure: ~L65-120
- SVO+SDF memory metrics structure: ~L125-170
- Memory tracker interface: ~L175-250

FileStructure: [2_MemoryManagement/Public/Interfaces/IBufferProvider.h]
- Buffer access mode enum: ~L15-30
- Buffer usage enum: ~L35-60
- Buffer stats structure: ~L65-100
- Buffer provider interface: ~L105-220

FileStructure: [2_MemoryManagement/Public/Interfaces/IPoolAllocator.h]
- Pool stats structure: ~L15-50
- Pool allocator interface: ~L55-175

FileStructure: [2_MemoryManagement/Public/ZeroCopyBuffer.h]
- Zero-copy buffer class declaration: ~L15-120
- GPU buffer integration: ~L125-175

FileStructure: [2_MemoryManagement/Public/SVOAllocator.h]
- SVO allocator class declaration: ~L15-90
- SVO-specific allocation optimizations: ~L95-150

### Implementation Patterns
- Memory Management: Hierarchical memory tiers (Hot, Warm, Cold, Archive) for performance optimization
- Reference Counting: Used for buffer management with AddRef/Release pattern to track usage
- Defragmentation: Time-bounded defragmentation operations with priority levels
- Statistics Tracking: Comprehensive metrics for memory usage by category, tier, and type
- Zero-Copy Buffers: Support for efficient CPU/GPU data sharing with minimal synchronization
- Memory Pools: Block-based allocation for specialized use cases with type-specific optimization
- Thread Safety: Read-write locks, critical sections, and atomic operations for thread-safe memory management
- Memory Budgets: Category-specific memory budgets to prevent resource exhaustion
- Memory Pressure: Progressive response to memory pressure conditions
- NUMA Awareness: Support for NUMA-aware memory allocation on platforms that support it

### UE5 Integration
- Uses UE5 RHI (Rendering Hardware Interface) for GPU buffer management
- Integrates with UE5 memory management primitives like FMalloc
- Utilizes UE5 threading primitives (FRWLock, FCriticalSection) for thread safety
- Leverages UE5 smart pointers (TSharedPtr, TSharedRef) for resource management
- Follows UE5 naming conventions and API patterns

### Potential Conflicts
- Multiple Initialize/Shutdown methods across different interfaces with similar signatures
- Multiple GetStats() methods returning different structure types depending on context
- Similar naming conventions for memory-related methods across different interfaces
- Potential confusion between general memory allocation and pool-based allocation
- Overlapping responsibility between IMemoryManager and more specialized allocators
- Multiple buffer provider implementations with different performance characteristics

### Known Issues & Constraints
- Memory mapping might not be available on all platforms with same performance characteristics
- Prediction accuracy depends on the quality of the cave network topology information
- Frame budgeting must be carefully tuned to avoid hitches during hibernation/reactivation
- Incremental operations might leave the system in temporary inconsistent states between frames
- Complex interdependencies between hibernation, compression, and streaming systems

## SYSTEM 3: Threading and Async Task System

### Class Hierarchy
- `IAsyncOperation` [3_ThreadingTaskSystem/Public/Interfaces/IAsyncOperation.h]: Interface
  - Purpose: Base interface for asynchronous operations in the mining architecture
  - Key methods:
    - `bool Initialize()` - Initializes the async operation manager
    - `void Shutdown()` - Shuts down the async operation manager
    - `bool IsInitialized() const` - Checks initialization status
    - `uint64 CreateOperation(const FString& OperationType, const FString& OperationName = TEXT(""))` - Creates a new async operation
    - `bool StartOperation(uint64 OperationId, const TMap<FString, FString>& Parameters = TMap<FString, FString>())` - Starts an async operation
    - `bool CancelOperation(uint64 OperationId, bool bWaitForCancellation = false)` - Cancels an async operation
    - `EAsyncStatus GetOperationStatus(uint64 OperationId) const` - Gets operation status
    - `FAsyncProgress GetOperationProgress(uint64 OperationId) const` - Gets progress information
    - `FAsyncResult GetOperationResult(uint64 OperationId) const` - Gets operation result
    - `bool WaitForCompletion(uint64 OperationId, uint32 TimeoutMs = 0)` - Waits for completion
    - `bool RegisterProgressCallback(uint64 OperationId, const FAsyncProgressDelegate& Callback, uint32 UpdateIntervalMs = 100)` - Registers progress callback
    - `bool RegisterCompletionCallback(uint64 OperationId, const FAsyncCompletionDelegate& Callback)` - Registers completion callback
    - `uint32 GetActiveOperationCount() const` - Gets count of active operations
    - `TArray<uint64> GetActiveOperations() const` - Gets IDs of all active operations
    - `TArray<uint64> GetOperationsOfType(const FString& OperationType) const` - Gets operations of specific type
    - `uint32 CleanupCompletedOperations(double MaxAgeSeconds = 300.0)` - Cleans up completed operations
    - `static IAsyncOperation& Get()` - Gets singleton instance

- `FAsyncOperationImpl` [3_ThreadingTaskSystem/Public/AsyncTaskManager.h]: Implements IAsyncOperation
  - Purpose: Concrete implementation of an asynchronous operation
  - Key methods:
    - Constructor and destructor
    - Getters for operation properties (ID, type, name)
    - Status and progress management
    - Callback registration and notification
  - Key members:
    - `uint64 Id` - Unique operation identifier
    - `FString Type` - Operation type name
    - `FString Name` - Operation name
    - `EAsyncStatus Status` - Current operation status
    - `FAsyncProgress Progress` - Progress information
    - `FAsyncResult Result` - Operation result
    - `TMap<FString, FString> Parameters` - Operation parameters
    - `TArray<FAsyncProgressDelegate> ProgressCallbacks` - Progress callbacks
    - `TArray<FAsyncCompletionDelegate> CompletionCallbacks` - Completion callbacks
    - Time tracking for creation, start, completion

- `FAsyncTaskManager` [3_ThreadingTaskSystem/Public/AsyncTaskManager.h]: Manager class
  - Purpose: Manages asynchronous operations and their lifecycles
  - Key methods:
    - Implementation of IAsyncOperation interface
    - Operation creation, tracking, and cleanup
  - Key members:
    - `TMap<uint64, TSharedPtr<FAsyncOperationImpl>> Operations` - Map of active operations
    - `TMap<FString, TArray<uint64>> OperationsByType` - Operations organized by type
    - `FCriticalSection OperationsLock` - Thread safety lock
    - `FThreadSafeBool bIsInitialized` - Initialization flag
    - `uint64 NextOperationId` - Counter for generating unique IDs
    - `static FAsyncTaskManager* Instance` - Singleton instance

- `ITaskScheduler` [3_ThreadingTaskSystem/Public/Interfaces/ITaskScheduler.h]: Interface
  - Purpose: Provides task scheduling capabilities optimized for mining operations
  - Key methods:
    - `bool Initialize()` - Initializes the task scheduler
    - `void Shutdown()` - Shuts down the task scheduler
    - `bool IsInitialized() const` - Checks initialization status
    - `uint64 ScheduleTask(TFunction<void()> TaskFunc, const FTaskConfig& Config, const FString& Desc = TEXT(""))` - Schedules task
    - `uint64 ScheduleTaskWithCallback(TFunction<void()> TaskFunc, TFunction<void(bool)> OnComplete, const FTaskConfig& Config, const FString& Desc = TEXT(""))` - Schedules task with callback
    - `bool CancelTask(uint64 TaskId)` - Cancels task
    - `ETaskStatus GetTaskStatus(uint64 TaskId) const` - Gets task status
    - `FTaskStats GetTaskStats(uint64 TaskId) const` - Gets task statistics
    - `bool GetTaskProgress(uint64 TaskId, float& OutProgress) const` - Gets task progress
    - `bool WaitForTask(uint64 TaskId, uint32 TimeoutMs = 0)` - Waits for task completion
    - `bool WaitForTasks(const TArray<uint64>& TaskIds, bool bWaitForAll = true, uint32 TimeoutMs = 0)` - Waits for multiple tasks
    - `uint32 GetWorkerThreadCount() const` - Gets worker thread count
    - `int32 GetCurrentThreadId() const` - Gets current thread ID
    - `bool IsTaskThread() const` - Checks if current thread is a task system thread
    - `bool SetThreadPriority(int32 ThreadId, EThreadPriority Priority)` - Sets thread priority
    - `bool SetThreadAffinity(int32 ThreadId, uint64 CoreMask)` - Sets thread affinity
    - `TMap<ETaskStatus, int32> GetTaskCounts() const` - Gets task counts by status
    - `static ITaskScheduler& Get()` - Gets singleton instance

- `FTaskScheduler` [3_ThreadingTaskSystem/Public/TaskScheduler.h]: Implements ITaskScheduler
  - Purpose: Concrete implementation of task scheduling for mining operations
  - Key methods:
    - Implementation of ITaskScheduler interface
    - Task creation, execution, and lifecycle management
  - Key members:
    - Task tracking and management structures
    - Thread pool and worker management
    - Priority queue integration

- `IThreadSafeQueue` [3_ThreadingTaskSystem/Public/Interfaces/IThreadSafeQueue.h]: Interface
  - Purpose: Provides thread-safe queue operations for concurrent access
  - Key methods:
    - `bool Initialize(int32 InCapacity = 0)` - Initializes queue with capacity
    - `void Shutdown()` - Shuts down the queue
    - `bool IsInitialized() const` - Checks initialization status
    - `EQueueResult Enqueue(void* Item)` - Enqueues an item
    - `EQueueResult EnqueueWithTimeout(void* Item, uint32 TimeoutMs)` - Enqueues with timeout
    - `EQueueResult Dequeue(void*& OutItem)` - Dequeues an item
    - `EQueueResult DequeueWithTimeout(void*& OutItem, uint32 TimeoutMs)` - Dequeues with timeout
    - `EQueueResult Peek(void*& OutItem) const` - Peeks at next item without removing
    - `bool IsEmpty() const` - Checks if queue is empty
    - `bool IsFull() const` - Checks if queue is full
    - `int32 GetSize() const` - Gets current size
    - `int32 GetCapacity() const` - Gets maximum capacity
    - `void Clear()` - Clears all items
    - `FQueueStats GetStats() const` - Gets queue statistics
    - `void ResetStats()` - Resets statistics
    - `void Close()` - Closes the queue
    - `bool IsClosed() const` - Checks if queue is closed
    - `bool SetCapacity(int32 NewCapacity)` - Sets queue capacity
    - `int32 EnqueueBatch(void** Items, int32 Count)` - Enqueues multiple items
    - `int32 DequeueBatch(void** OutItems, int32 MaxCount)` - Dequeues multiple items
    - `static IThreadSafeQueue& Get()` - Gets singleton instance

- `TThreadSafeQueue<T>` [3_ThreadingTaskSystem/Public/Interfaces/IThreadSafeQueue.h]: Template class
  - Purpose: Type-safe wrapper for IThreadSafeQueue
  - Key methods:
    - Type-safe wrappers for all IThreadSafeQueue methods
  - Key members:
    - `IThreadSafeQueue* Queue` - Underlying queue implementation

- `ITransactionManager` [3_ThreadingTaskSystem/Public/Interfaces/ITransactionManager.h]: Interface
  - Purpose: Manages zone-based transactions with concurrency control
  - Key methods:
    - Transaction creation, validation, and execution
    - Conflict detection and resolution
    - Zone version management

- `FTransactionManager` [3_ThreadingTaskSystem/Public/TransactionManager.h]: Implements ITransactionManager
  - Purpose: Handles mining transactions with different concurrency models
  - Key methods:
    - Implementation of ITransactionManager interface
    - Transaction processing and conflict resolution
  - Key members:
    - Zone version tracking
    - Transaction history
    - Conflict statistics

- `FThreadSafeOperationQueue` [3_ThreadingTaskSystem/Public/ThreadSafeOperationQueue.h]: Implementation class
  - Purpose: Specialized thread-safe queue for mining operations
  - Key methods:
    - Implementation of IThreadSafeQueue interface
    - Mining-specific optimizations
  - Key members:
    - Internal queue structures
    - Concurrency control primitives

- `FPriorityTaskQueue` [3_ThreadingTaskSystem/Public/PriorityTaskQueue.h]: Implementation class
  - Purpose: Task queue with priority-based scheduling
  - Key methods:
    - Priority-based enqueue and dequeue
    - Task prioritization and ordering
  - Key members:
    - Priority buckets for tasks
    - Task ordering within priorities

- `FParallelExecutor` [3_ThreadingTaskSystem/Public/ParallelExecutor.h]: Implementation class
  - Purpose: Executes tasks in parallel with workload distribution
  - Key methods:
    - Work distribution and parallel execution
    - Load balancing across worker threads
  - Key members:
    - Worker thread pool
    - Work stealing mechanisms

- `FZoneManager` [3_ThreadingTaskSystem/Public/ZoneManager.h]: Implementation class
  - Purpose: Manages mining zones with multi-threading support
  - Key methods:
    - Zone creation and management
    - Zone-based transaction coordination
  - Key members:
    - Zone grid management
    - Zone state tracking

### Structures
- `FAsyncProgress` [3_ThreadingTaskSystem/Public/Interfaces/IAsyncOperation.h]
  - Purpose: Tracks progress of asynchronous operations
  - Key members:
    - `float CompletionPercentage` - Progress percentage (0.0 - 1.0)
    - `int32 CurrentStage` - Current operation stage
    - `int32 TotalStages` - Total number of stages
    - `FString StatusMessage` - Optional status message
    - `double ElapsedTimeSeconds` - Time elapsed since start
    - `double EstimatedTimeRemainingSeconds` - Estimated time remaining
    - `int64 ItemsProcessed` - Number of items processed
    - `int64 TotalItems` - Total items to process

- `FAsyncResult` [3_ThreadingTaskSystem/Public/Interfaces/IAsyncOperation.h]
  - Purpose: Holds result of an asynchronous operation
  - Key members:
    - `bool bSuccess` - Whether operation succeeded
    - `FString ErrorMessage` - Error message if failed
    - `int32 ErrorCode` - Error code if failed
    - `bool bCancelled` - Whether operation was cancelled
    - `TSharedPtr<void> ResultData` - Optional result data

- `FTaskConfig` [3_ThreadingTaskSystem/Public/Interfaces/ITaskScheduler.h]
  - Purpose: Configuration for scheduled tasks
  - Key members:
    - `ETaskPriority Priority` - Task priority level
    - `ETaskType Type` - Task type for specialized handling
    - `int32 PreferredCore` - Preferred CPU core
    - `bool bCancellable` - Whether task can be canceled
    - `bool bSupportsProgress` - Whether task reports progress
    - `TArray<FTaskDependency> Dependencies` - Task dependencies
    - `uint32 MaxExecutionTimeMs` - Maximum execution time
    - `bool bAutoRetry` - Whether to auto-retry on failure
    - `uint32 MaxRetries` - Maximum retry attempts
    - `uint8 RetryPriorityBoost` - Priority boost for retries

- `FTaskStats` [3_ThreadingTaskSystem/Public/Interfaces/ITaskScheduler.h]
  - Purpose: Statistics for task performance monitoring
  - Key members:
    - `double QueueTimeMs` - Time spent in queue
    - `double ExecutionTimeMs` - Time spent executing
    - `uint32 RetryCount` - Number of retry attempts
    - `uint64 PeakMemoryBytes` - Peak memory usage
    - `uint32 ExecutingThreadId` - Thread that executed the task
    - `int32 ExecutingCore` - CPU core that executed the task

- `FQueueStats` [3_ThreadingTaskSystem/Public/Interfaces/IThreadSafeQueue.h]
  - Purpose: Statistics for queue performance monitoring
  - Key members:
    - `int32 CurrentSize` - Current number of items
    - `int32 Capacity` - Maximum capacity
    - `uint64 TotalEnqueued` - Total items enqueued
    - `uint64 TotalDequeued` - Total items dequeued
    - `uint64 EnqueueFailures` - Failed enqueue operations
    - `uint64 DequeueFailures` - Failed dequeue operations
    - `uint64 TimeoutCount` - Number of timeouts
    - `int32 PeakSize` - Peak queue size
    - `double AverageEnqueueWaitTimeMs` - Average enqueue wait time
    - `double AverageDequeueWaitTimeMs` - Average dequeue wait time
    - `bool bIsClosed` - Whether queue is closed

- `FTaskDependency` [3_ThreadingTaskSystem/Public/Interfaces/ITaskScheduler.h]
  - Purpose: Defines task dependencies for complex task chains
  - Key members:
    - `uint64 TaskId` - ID of dependent task
    - `bool bRequired` - Whether dependency is required
    - `uint32 TimeoutMs` - Timeout for waiting on dependency

### Enumerations
- `EAsyncStatus` [3_ThreadingTaskSystem/Public/Interfaces/IAsyncOperation.h]
  - Purpose: Status codes for asynchronous operations
  - Values: NotStarted, InProgress, Completed, Failed, Cancelled, TimedOut, Invalid

- `ETaskPriority` [3_ThreadingTaskSystem/Public/Interfaces/ITaskScheduler.h]
  - Purpose: Task priority levels for scheduling
  - Values: Critical, High, Normal, Low, Minimal

- `ETaskStatus` [3_ThreadingTaskSystem/Public/Interfaces/ITaskScheduler.h]
  - Purpose: Status codes for tasks
  - Values: Queued, Running, Completed, Cancelled, Failed

- `ETaskType` [3_ThreadingTaskSystem/Public/Interfaces/ITaskScheduler.h]
  - Purpose: Task type classification for specialized handling
  - Values: General, MiningOperation, SDFOperation, OctreeTraversal, MaterialOperation, ZoneTransaction

- `EQueueResult` [3_ThreadingTaskSystem/Public/Interfaces/IThreadSafeQueue.h]
  - Purpose: Result codes for queue operations
  - Values: Success, QueueFull, QueueEmpty, Timeout, QueueClosed, Error

### Delegates
- `FAsyncProgressDelegate` [3_ThreadingTaskSystem/Public/Interfaces/IAsyncOperation.h]
  - Purpose: Callback for async operation progress updates
  - Signature: `DECLARE_DELEGATE_OneParam(FAsyncProgressDelegate, const FAsyncProgress&)`

- `FAsyncCompletionDelegate` [3_ThreadingTaskSystem/Public/Interfaces/IAsyncOperation.h]
  - Purpose: Callback for async operation completion
  - Signature: `DECLARE_DELEGATE_OneParam(FAsyncCompletionDelegate, const FAsyncResult&)`

### Navigation Landmarks
FileStructure: [3_ThreadingTaskSystem/Public/Interfaces/IAsyncOperation.h]
- Async operation status enum: ~L12-30
- Async progress structure: ~L35-67
- Async result structure: ~L72-110
- Delegates declaration: ~L112-120
- IAsyncOperation interface: ~L125-195

FileStructure: [3_ThreadingTaskSystem/Public/AsyncTaskManager.h]
- FAsyncOperationImpl class: ~L10-95
- FAsyncTaskManager class: ~L100-170

FileStructure: [3_ThreadingTaskSystem/Public/Interfaces/ITaskScheduler.h]
- Task priority enum: ~L15-25
- Task status enum: ~L30-40
- Task type enum: ~L45-60
- Task dependency structure: ~L65-75
- Task config structure: ~L80-115
- Task stats structure: ~L120-135
- ITaskScheduler interface: ~L145-230

FileStructure: [3_ThreadingTaskSystem/Public/Interfaces/IThreadSafeQueue.h]
- Queue result enum: ~L10-25
- Queue stats structure: ~L30-65
- IThreadSafeQueue interface: ~L75-165
- TThreadSafeQueue template: ~L170-270

### Implementation Patterns
- Singleton Pattern: Each manager class implements a singleton pattern with thread-safe initialization
  ```cpp
  static ITaskScheduler& Get();
  static FTaskScheduler* Instance;
  static FThreadSafeBool bInstanceInitialized;
  ```

- Thread Safety: Comprehensive thread safety mechanisms throughout the system
  ```cpp
  FCriticalSection OperationsLock;
  FThreadSafeBool bIsInitialized;
  FThreadSafeCounter PendingOperations;
  ```

- Task Delegation: Delegation pattern for task execution and callbacks
  ```cpp
  TFunction<void()> TaskFunc;
  TFunction<void(bool)> OnComplete;
  ```

- Progress Reporting: Standardized progress tracking and reporting
  ```cpp
  FAsyncProgress Progress;
  FAsyncProgressDelegate ProgressCallback;
  ```

- Resource Management: Careful resource cleanup for tasks and operations
  ```cpp
  virtual void Shutdown() override;
  virtual uint32 CleanupCompletedOperations(double MaxAgeSeconds) override;
  ```

- Prioritization: Multi-level priority handling for tasks
  ```cpp
  ETaskPriority Priority;
  uint8 RetryPriorityBoost;
  ```

- Dependency Management: Support for complex task dependencies
  ```cpp
  TArray<FTaskDependency> Dependencies;
  bool WaitForTasks(const TArray<uint64>& TaskIds, bool bWaitForAll, uint32 TimeoutMs);
  ```

### UE5 Integration
- Uses UE5 threading primitives (FCriticalSection, FEvent, FThreadSafeBool)
- Implements UE5 interfaces for reflection and blueprint exposure
- Leverages UE5 task graph system for certain operations
- Compatible with UE5's async loading and streaming systems
- Follows UE5 naming and design conventions

### Naming Patterns
- Interface classes: Prefix with 'I' (ITaskScheduler, IThreadSafeQueue)
- Implementation classes: Prefix with 'F' (FTaskScheduler, FAsyncTaskManager)
- Enumerations: Prefix with 'E' (ETaskPriority, EAsyncStatus)
- Structures: Prefix with 'F' (FTaskConfig, FAsyncProgress)
- Delegates: Suffix with 'Delegate' (FAsyncProgressDelegate)
- Boolean methods: Prefix with 'Is' or 'Has' (IsInitialized, IsTaskThread)
- Parameters: Prefix with 'In' for inputs, 'Out' for outputs (InCapacity, OutProgress)

### Potential Conflicts
- Multiple Initialize/Shutdown methods across different interfaces
  - IAsyncOperation::Initialize() vs ITaskScheduler::Initialize()
  - All system components have similar lifecycle methods

- Multiple Get() singleton methods with different return types
  - IAsyncOperation::Get() vs ITaskScheduler::Get()
  - Each subsystem has its own singleton accessor

- Multiple status enumerations with similar values
  - EAsyncStatus vs ETaskStatus
  - Different but related status tracking systems

- Queue vs Task vs Operation terminology
  - Clear conceptual separation needed between these related concepts

### Architectural Boundaries
- Async Task System provides the foundation for other systems' concurrent operations
- Transaction Manager bridges between task system and zone-based mining operations
- Clear separation between task scheduling (ITaskScheduler) and async operation management (IAsyncOperation)
- Thread-safe data structures (IThreadSafeQueue) support multiple concurrent systems

### Dependencies
- Depends on UE5 Core (CoreMinimal.h, UObject)
- Depends on System 1 (Core Registry) for type resolution
- Required by most other systems for concurrent operations
- Particularly important for System 2.3 (Zone-Based Concurrent Mining)

### Thread Safety Model
- Task Creation: Thread-safe via critical sections
- Operation Execution: Managed by task scheduler with isolation
- Progress Updates: Atomic operations and thread-safe counters
- Result Access: Protected by synchronization primitives
- Queue Operations: Fully thread-safe with internal locking

### Performance Considerations
- Task prioritization ensures critical mining operations complete first
- Work stealing algorithms balance load across available cores
- NUMA awareness for optimal memory access patterns
- Avoids over-subscription with worker thread pool management
- Uses atomic operations where possible to minimize lock contention

### Known Issues & Constraints
- Complex task dependencies can potentially lead to deadlocks
- Task cancellation during certain phases may leave resources in inconsistent states
- Thread affinity settings may not be honored on all platforms
- Progress reporting has minimal performance impact but is not zero-cost
